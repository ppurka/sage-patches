# HG changeset patch
# User Punarbasu Purkayastha <ppurka@gmail.com>
# Date 1337431080 -28800
# Node ID 326401aa2def0c15759b005e33a365a49b59b38f
# Parent  a225ede259f7484a2fdf5fd1378bbe84b0b49b2a
refactor tick formatting code, and remove extraneous spaces

diff --git a/sage/plot/animate.py b/sage/plot/animate.py
--- a/sage/plot/animate.py
+++ b/sage/plot/animate.py
@@ -4,7 +4,7 @@
 EXAMPLES:
 We plot a circle shooting up to the right::
 
-    sage: a = animate([circle((i,i), 1-1/(i+1), hue=i/10) for i in srange(0,2,0.2)], 
+    sage: a = animate([circle((i,i), 1-1/(i+1), hue=i/10) for i in srange(0,2,0.2)],
     ...               xmin=0,ymin=0,xmax=2,ymax=2,figsize=[2,2])
     sage: a.show() # optional -- ImageMagick
 """
@@ -26,25 +26,25 @@
 class Animation(SageObject):
     r"""
     Return an animation of a sequence of plots of objects.
-    
+
     INPUT:
-    
-    
+
+
     -  ``v`` - list of Sage objects. These should
        preferably be graphics objects, but if they aren't then plot is
        called on them.
-    
+
     -  ``xmin, xmax, ymin, ymax`` - the ranges of the x and
        y axes.
-    
+
     -  ``**kwds`` - all additional inputs are passed onto
        the rendering command. E.g., use figsize to adjust the resolution
        and aspect ratio.
-    
-    
+
+
     EXAMPLES::
-    
-        sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.3)], 
+
+        sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.3)],
         ...                xmin=0, xmax=2*pi, figsize=[2,1])
         sage: a
         Animation with 21 frames
@@ -52,17 +52,17 @@
         Animation with 5 frames
         sage: a.show()          # optional -- ImageMagick
         sage: a[:5].show()      # optional -- ImageMagick
-    
+
     The ``show`` function takes arguments to specify the
     delay between frames (measured in hundredths of a second, default
     value 20) and the number of iterations (default value 0, which
     means to iterate forever). To iterate 4 times with half a second
     between each frame::
-    
+
         sage: a.show(delay=50, iterations=4) # optional -- ImageMagick
-    
+
     An animation of drawing a parabola::
-    
+
         sage: step = 0.1
         sage: L = Graphics()
         sage: v = []
@@ -72,15 +72,15 @@
         sage: a = animate(v, xmin=0, ymin=0)
         sage: a.show() # optional -- ImageMagick
         sage: show(L)
-    
+
     TESTS: This illustrates that ticket #2066 is fixed (setting axes
     ranges when an endpoint is 0)::
-    
+
         sage: animate([plot(sin, -1,1)], xmin=0, ymin=0)._kwds['xmin']
         0
-        
+
     We check that Trac #7981 is fixed::
-    
+
         sage: a = animate([plot(sin(x + float(k)), (0, 2*pi), ymin=-5, ymax=5)
         ...            for k in srange(0,2*pi,0.3)])
         sage: a.show() # optional -- ImageMagick
@@ -89,11 +89,11 @@
         r"""
         Return an animation of a sequence of plots of objects.
 
-        See documentation of ``animate`` for more details and examples. 
+        See documentation of ``animate`` for more details and examples.
 
         EXAMPLES::
 
-            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.3)], 
+            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.3)],
             ...                xmin=0, xmax=2*pi, figsize=[2,1])
             sage: a
             Animation with 21 frames
@@ -113,9 +113,9 @@
         Returns a dictionary which is a combination of the all the
         dictionaries in kwds_tuple. This also does the appropriate thing
         for taking the mins and maxes of all of the x/y mins/maxes.
-        
+
         EXAMPLES::
-        
+
             sage: a = animate([plot(sin, -1,1)], xmin=0, ymin=0)
             sage: kwds1 = {'a':1, 'b':2, 'xmin':2, 'xmax':5}
             sage: kwds2 = {'b':3, 'xmin':0, 'xmax':4}
@@ -152,7 +152,7 @@
 
             sage: a = animate([x, x^2, x^3, x^4])
             sage: a[2].show()       # optional -- ImageMagick
-            sage: a = animate([circle((i,-i), 1-1/(i+1), hue=i/10) for i in srange(0,2,0.2)], 
+            sage: a = animate([circle((i,-i), 1-1/(i+1), hue=i/10) for i in srange(0,2,0.2)],
             ...               xmin=0,ymin=-2,xmax=2,ymax=0,figsize=[2,2])
             sage: a
             Animation with 10 frames
@@ -169,10 +169,10 @@
     def _repr_(self):
         """
         Print representation for an animation.
-        
+
         EXAMPLES::
-        
-            sage: a = animate([circle((i,-i), 1-1/(i+1), hue=i/10) for i in srange(0,2,0.2)], 
+
+            sage: a = animate([circle((i,-i), 1-1/(i+1), hue=i/10) for i in srange(0,2,0.2)],
             ...               xmin=0,ymin=-2,xmax=2,ymax=0,figsize=[2,2])
             sage: a
             Animation with 10 frames
@@ -185,15 +185,15 @@
         """
         Add two animations. This has the effect of superimposing the two
         animations frame-by-frame.
-        
+
         EXAMPLES: We add and multiply two animations.
-        
+
         ::
-        
-            sage: a = animate([circle((i,0),1) for i in srange(0,2,0.4)], 
+
+            sage: a = animate([circle((i,0),1) for i in srange(0,2,0.4)],
             ...                xmin=0, ymin=-1, xmax=3, ymax=1, figsize=[2,1])
             sage: a.show()   # optional -- ImageMagick
-            sage: b = animate([circle((0,i),1,hue=0) for i in srange(0,2,0.4)], 
+            sage: b = animate([circle((0,i),1,hue=0) for i in srange(0,2,0.4)],
             ...                xmin=0, ymin=-1, xmax=1, ymax=3, figsize=[1,2])
             sage: b.show() # optional
             sage: (a*b).show()    # optional -- ImageMagick
@@ -201,29 +201,29 @@
         """
         if not isinstance(other, Animation):
             other = Animation(other)
-            
+
         kwds = self._combine_kwds(self._kwds, other._kwds)
 
         #Combine the frames
         m = max(len(self._frames), len(other._frames))
         frames = [a+b for a,b in zip(self._frames, other._frames)]
         frames += self._frames[m:] + other._frames[m:]
-                
+
         return Animation(frames, **kwds)
 
     def __mul__(self, other):
         """
         Multiply two animations. This has the effect of appending the two
         animations (the second comes after the first).
-        
+
         EXAMPLES: We add and multiply two animations.
-        
+
         ::
-        
-            sage: a = animate([circle((i,0),1,thickness=20*i) for i in srange(0,2,0.4)], 
+
+            sage: a = animate([circle((i,0),1,thickness=20*i) for i in srange(0,2,0.4)],
             ...                xmin=0, ymin=-1, xmax=3, ymax=1, figsize=[2,1], axes=False)
             sage: a.show()     # optional -- ImageMagick
-            sage: b = animate([circle((0,i),1,hue=0,thickness=20*i) for i in srange(0,2,0.4)], 
+            sage: b = animate([circle((0,i),1,hue=0,thickness=20*i) for i in srange(0,2,0.4)],
             ...                xmin=0, ymin=-1, xmax=1, ymax=3, figsize=[1,2], axes=False)
             sage: b.show()             # optional -- ImageMagick
             sage: (a*b).show()         # optional -- ImageMagick
@@ -233,16 +233,16 @@
             other = Animation(other)
 
         kwds = self._combine_kwds(self._kwds, other._kwds)
-        
+
         return Animation(self._frames + other._frames, **kwds)
 
     def png(self, dir=None):
         """
         Return the absolute path to a temp directory that contains the
         rendered PNG's of all the images in this animation.
-        
+
         EXAMPLES::
-        
+
             sage: a = animate([plot(x^2 + n) for n in range(4)])
             sage: d = a.png()
             sage: v = os.listdir(d); v.sort(); v
@@ -264,25 +264,25 @@
         """
         Return a graphics array with the given number of columns with plots
         of the frames of this animation.
-        
+
         EXAMPLES::
-        
+
             sage: E = EllipticCurve('37a')
             sage: v = [E.change_ring(GF(p)).plot(pointsize=30) for p in [97, 101, 103, 107]]
             sage: a = animate(v, xmin=0, ymin=0)
             sage: a
             Animation with 4 frames
             sage: a.show()        # optional -- ImageMagick
-        
+
         ::
-        
+
             sage: g = a.graphics_array()
             sage: print g
             Graphics Array of size 1 x 3
             sage: g.show(figsize=[4,1]) # optional
-        
+
         ::
-        
+
             sage: g = a.graphics_array(ncols=2)
             sage: print g
             Graphics Array of size 2 x 2
@@ -297,7 +297,7 @@
         r"""
         Returns an animated gif composed from rendering the graphics
         objects in self.
-        
+
         This function will only work if either (a) the ImageMagick
         software suite is installed, i.e., you have the ``convert``
         command or (b) ``ffmpeg`` is installed.  See
@@ -329,7 +329,7 @@
 
         EXAMPLES::
 
-            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.7)], 
+            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.7)],
             ...                xmin=0, xmax=2*pi, figsize=[2,1])
             sage: dir = tmp_dir() + '/'
             sage: a.gif()              # not tested
@@ -338,7 +338,7 @@
             Animation saved to .../my_animation.gif.
             sage: a.gif(savefile=dir + 'my_animation.gif', show_path=True, use_ffmpeg=True) # optional -- ffmpeg
             Animation saved to .../my_animation.gif.
-        
+
         .. note::
 
            If neither ffmpeg nor ImageMagick is installed, you will
@@ -402,17 +402,17 @@
     def show(self, delay=20, iterations=0):
         r"""
         Show this animation.
-        
+
         INPUT:
-        
-        
+
+
         -  ``delay`` - (default: 20) delay in hundredths of a
            second between frames
-        
+
         -  ``iterations`` - integer (default: 0); number of
            iterations of animation. If 0, loop forever.
-        
-        
+
+
         .. note::
 
            Currently this is done using an animated gif, though this
@@ -424,10 +424,10 @@
 
         EXAMPLES::
 
-            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.7)], 
+            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.7)],
             ...                xmin=0, xmax=2*pi, figsize=[2,1])
             sage: a.show()       # optional -- ImageMagick
-        
+
         The preceding will loop the animation forever. If you want to show
         only three iterations instead::
 
@@ -441,7 +441,7 @@
 
            If you don't have ffmpeg or ImageMagick installed, you will
            get an error message like this::
-        
+
               Error: Neither ImageMagick nor ffmpeg appears to be installed. Saving an
               animation to a GIF file or displaying an animation requires one of these
               packages, so please install one of them and try again.
@@ -452,7 +452,7 @@
             filename = sage.misc.misc.tmp_filename() + '.gif'
             self.gif(savefile=filename, delay=delay, iterations=iterations)
             return
-        
+
         if plot.EMBEDDED_MODE:
             self.gif(delay = delay, iterations = iterations)
         else:
@@ -618,7 +618,7 @@
 
         EXAMPLES::
 
-            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.7)], 
+            sage: a = animate([sin(x + float(k)) for k in srange(0,2*pi,0.7)],
             ...                xmin=0, xmax=2*pi, figsize=[2,1])
             sage: dir = tmp_dir() + '/'
             sage: a.save()         # not tested
diff --git a/sage/plot/arc.py b/sage/plot/arc.py
--- a/sage/plot/arc.py
+++ b/sage/plot/arc.py
@@ -52,7 +52,7 @@
         Initializes base class ``Arc``.
 
         EXAMPLES:
-        
+
             sage: A = arc((2,3),1,1,pi/4,(0,pi))
             sage: A[0].x == 2
             True
@@ -88,14 +88,14 @@
         self.s2 = float(s2)
         if self.s2 < self.s1:
             self.s1,self.s2=self.s2,self.s1
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
 
         The bounding box is computed as minimal as possible.
-    
+
         EXAMPLES:
 
         An example without angle::
@@ -148,29 +148,29 @@
         sin_angle = sin(angle)
 
         if cos_angle > 1-epsilon:
-            xmin=-r1; ymin=-r2        
+            xmin=-r1; ymin=-r2
             xmax=r1; ymax=r2
             axmin = pi; axmax = 0
             aymin = 3*pi/2; aymax = pi/2
 
         elif cos_angle < -1+epsilon:
-            xmin=-r1; ymin=-r2        
+            xmin=-r1; ymin=-r2
             xmax=r1; ymax=r2
             axmin=0; axmax=pi
             aymin=pi/2; aymax=3*pi/2
-            
+
         elif sin_angle > 1-epsilon:
             xmin=-r2; ymin=-r1
             xmax=r2; ymax=r1
             axmin = pi/2; axmax = 3*pi/2
             aymin = pi; aymax = 0
-            
+
         elif sin_angle < -1+epsilon:
             xmin=-r2; ymin=-r1
             xmax=r2; ymax=r1
             axmin = 3*pi/2; axmax = pi/2
             aymin = 0; aymax = pi
-            
+
         else:
             tan_angle = sin_angle / cos_angle
             axmax = atan(-r2/r1*tan_angle)
@@ -183,7 +183,7 @@
                 axmax = fmod(axmax+pi,twopi)
             xmin = -xmax
             axmin = fmod(axmax + pi,twopi)
-            
+
             aymax = atan(r2/(r1*tan_angle))
             if aymax < 0: aymax += twopi
             ymax = (
@@ -191,7 +191,7 @@
               r2 * cos_angle * sin(aymax))
             if ymax < 0:
                 ymax = -ymax
-                aymax = fmod(aymax+pi,twopi)            
+                aymax = fmod(aymax+pi,twopi)
             ymin = -ymax
             aymin = fmod(aymax + pi, twopi)
 
@@ -206,7 +206,7 @@
             x2 = cos_angle*r1*cos(s2) - sin_angle*r2*sin(s2)
             y1 = sin_angle*r1*cos(s1) + cos_angle*r2*sin(s1)
             y2 = sin_angle*r1*cos(s2) + cos_angle*r2*sin(s2)
-            
+
             if is_cyclic_ordered(s1,s2,axmin): xmin = min(x1,x2)
             if is_cyclic_ordered(s1,s2,aymin): ymin = min(y1,y2)
             if is_cyclic_ordered(s1,s2,axmax): xmax = max(x1,x2)
@@ -297,13 +297,13 @@
 
     - ``center`` - 2-tuple of real numbers - position of the center.
 
-    - ``r1``, ``r2`` - positive real numbers - radii of the ellipse. If only ``r1`` 
-      is set, then the two radii are supposed to be equal and this function returns 
+    - ``r1``, ``r2`` - positive real numbers - radii of the ellipse. If only ``r1``
+      is set, then the two radii are supposed to be equal and this function returns
       an arc of of circle.
 
     - ``angle`` - real number - angle between the horizontal and the axis that
       corresponds to ``r1``.
-    
+
     - ``sector`` - 2-tuple (default: (0,2*pi))- angles sector in which the arc will
       be drawn.
 
diff --git a/sage/plot/arrow.py b/sage/plot/arrow.py
--- a/sage/plot/arrow.py
+++ b/sage/plot/arrow.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #                     2009 Emily Kirkman
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
@@ -26,7 +26,7 @@
     def __init__(self, path, options):
         """
         Returns an arrow graphics primitive along the provided path (bezier curve).
-        
+
         EXAMPLES::
 
             sage: from sage.plot.arrow import CurveArrow
@@ -44,11 +44,11 @@
         self.codes = codes
         self.vertices = np.array(vertices, np.float)
         GraphicPrimitive.__init__(self, options)
-        
+
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.arrow import CurveArrow
@@ -63,7 +63,7 @@
                 'xmax': self.vertices[:,0].max(),
                 'ymin': self.vertices[:,1].min(),
                 'ymax': self.vertices[:,1].max()}
-        
+
     def _allowed_options(self):
         """
         Return the dictionary of allowed options for the curve arrow graphics primitive.
@@ -72,14 +72,14 @@
 
              sage: from sage.plot.arrow import CurveArrow
              sage: list(sorted(CurveArrow(path=[[(0,0),(2,3)]],options={})._allowed_options().iteritems()))
-             [('arrowsize', 'The size of the arrowhead'), 
-             ('arrowstyle', 'todo'), 
-             ('head', '2-d only: Which end of the path to draw the head (one of 0 (start), 1 (end) or 2 (both)'), 
-             ('hue', 'The color given as a hue.'), 
+             [('arrowsize', 'The size of the arrowhead'),
+             ('arrowstyle', 'todo'),
+             ('head', '2-d only: Which end of the path to draw the head (one of 0 (start), 1 (end) or 2 (both)'),
+             ('hue', 'The color given as a hue.'),
              ('legend_label', 'The label for this item in the legend.'),
-             ('linestyle', "2d only: The style of the line, which is one of 'dashed', 'dotted', 'solid', 'dashdot'."), 
-             ('rgbcolor', 'The color as an RGB tuple.'), 
-             ('width', 'The width of the shaft of the arrow, in points.'), 
+             ('linestyle', "2d only: The style of the line, which is one of 'dashed', 'dotted', 'solid', 'dashdot'."),
+             ('rgbcolor', 'The color as an RGB tuple.'),
+             ('width', 'The width of the shaft of the arrow, in points.'),
              ('zorder', '2-d only: The layer level in which to draw')]
         """
         return {'width':'The width of the shaft of the arrow, in points.',
@@ -92,7 +92,7 @@
                 'zorder':'2-d only: The layer level in which to draw',
                 'head':'2-d only: Which end of the path to draw the head (one of 0 (start), 1 (end) or 2 (both)',
                 'linestyle':"2d only: The style of the line, which is one of 'dashed', 'dotted', 'solid', 'dashdot'."}
-        
+
     def _repr_(self):
         """
         Text representation of an arrow graphics primitive.
@@ -104,7 +104,7 @@
             'CurveArrow from (0, 0) to (2, 3)'
         """
         return "CurveArrow from %s to %s"%(self.path[0][0],self.path[-1][-1])
-        
+
     def _render_on_subplot(self, subplot):
         """
         Render this arrow in a subplot.  This is the key function that
@@ -131,13 +131,13 @@
         from matplotlib.path import Path
         bpath = Path(self.vertices, self.codes)
         p = FancyArrowPatch(path=bpath,
-                            lw=width, arrowstyle='%s,head_width=%s,head_length=%s'%(style,head_width, head_length), 
+                            lw=width, arrowstyle='%s,head_width=%s,head_length=%s'%(style,head_width, head_length),
                             fc=color, ec=color, linestyle=options['linestyle'])
         p.set_zorder(options['zorder'])
         p.set_label(options['legend_label'])
         subplot.add_patch(p)
         return p
-    
+
 
 class Arrow(GraphicPrimitive):
     """
@@ -152,7 +152,7 @@
         sage: type(P)
         <class 'sage.plot.arrow.Arrow'>
         sage: P
-        Arrow from (0.0,1.0) to (2.0,3.0) 
+        Arrow from (0.0,1.0) to (2.0,3.0)
     """
     def __init__(self, xtail, ytail, xhead, yhead, options):
         """
@@ -162,13 +162,13 @@
 
             sage: from sage.plot.arrow import Arrow
             sage: Arrow(0,0,2,3,{})
-            Arrow from (0.0,0.0) to (2.0,3.0) 
+            Arrow from (0.0,0.0) to (2.0,3.0)
         """
         self.xtail = float(xtail)
         self.xhead = float(xhead)
         self.ytail = float(ytail)
         self.yhead = float(yhead)
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
@@ -186,7 +186,7 @@
                 'xmax': max(self.xtail, self.xhead),
                 'ymin': min(self.ytail, self.yhead),
                 'ymax': max(self.ytail, self.yhead)}
-                
+
 
     def _allowed_options(self):
         """
@@ -196,14 +196,14 @@
 
              sage: from sage.plot.arrow import Arrow
              sage: list(sorted(Arrow(0,0,2,3,{})._allowed_options().iteritems()))
-             [('arrowshorten', 'The length in points to shorten the arrow.'), 
-             ('arrowsize', 'The size of the arrowhead'), 
-             ('head', '2-d only: Which end of the path to draw the head (one of 0 (start), 1 (end) or 2 (both)'), 
-             ('hue', 'The color given as a hue.'), 
+             [('arrowshorten', 'The length in points to shorten the arrow.'),
+             ('arrowsize', 'The size of the arrowhead'),
+             ('head', '2-d only: Which end of the path to draw the head (one of 0 (start), 1 (end) or 2 (both)'),
+             ('hue', 'The color given as a hue.'),
              ('legend_label', 'The label for this item in the legend.'),
-             ('linestyle', "2d only: The style of the line, which is one of 'dashed', 'dotted', 'solid', 'dashdot'."), 
-             ('rgbcolor', 'The color as an RGB tuple.'), 
-             ('width', 'The width of the shaft of the arrow, in points.'), 
+             ('linestyle', "2d only: The style of the line, which is one of 'dashed', 'dotted', 'solid', 'dashdot'."),
+             ('rgbcolor', 'The color as an RGB tuple.'),
+             ('width', 'The width of the shaft of the arrow, in points.'),
              ('zorder', '2-d only: The layer level in which to draw')]
         """
         return {'width':'The width of the shaft of the arrow, in points.',
@@ -218,7 +218,7 @@
 
     def _plot3d_options(self, options=None):
         """
-        Translate 2D plot options into 3D plot options. 
+        Translate 2D plot options into 3D plot options.
 
         EXAMPLES::
 
@@ -248,7 +248,7 @@
 
     def plot3d(self, ztail=0, zhead=0, **kwds):
         """
-        Takes 2D plot and places it in 3D.  
+        Takes 2D plot and places it in 3D.
 
         EXAMPLES::
 
@@ -264,8 +264,8 @@
             sage: A.jmol_repr(A.testing_render_params())[0][0]
             'draw line_1 diameter 2 arrow {0.0 0.0 3.0}  {1.0 1.0 3.0} '
 
-        Optional arguments place both the head and tail outside the 
-        `xy`-plane, but at different heights.  This must be done on 
+        Optional arguments place both the head and tail outside the
+        `xy`-plane, but at different heights.  This must be done on
         the graphics primitive obtained by indexing::
 
             sage: A=arrow((0,0),(1,1))[0].plot3d(3,4)
@@ -297,7 +297,7 @@
 
         EXAMPLES:
 
-        This function implicitly ends up rendering this arrow on 
+        This function implicitly ends up rendering this arrow on
         a matplotlib subplot::
 
             sage: arrow((0,1), (2,-1))
@@ -316,7 +316,7 @@
         color = to_mpl_color(options['rgbcolor'])
         from matplotlib.patches import FancyArrowPatch
         p = FancyArrowPatch((self.xtail, self.ytail), (self.xhead, self.yhead),
-                            lw=width, arrowstyle='%s,head_width=%s,head_length=%s'%(style,head_width, head_length), 
+                            lw=width, arrowstyle='%s,head_width=%s,head_length=%s'%(style,head_width, head_length),
                             shrinkA=arrowshorten_end, shrinkB=arrowshorten_end,
                             fc=color, ec=color, linestyle=options['linestyle'])
         p.set_zorder(options['zorder'])
@@ -347,7 +347,7 @@
 @options(width=2, rgbcolor=(0,0,1),zorder=2, head = 1, linestyle='solid', legend_label=None)
 def arrow2d(tailpoint=None, headpoint=None, path=None, **options):
     """
-    If tailpoint and headpoint are provided, returns an arrow from (xmin, ymin) 
+    If tailpoint and headpoint are provided, returns an arrow from (xmin, ymin)
     to (xmax, ymax).  If tailpoint or headpoint is None and path is not None,
     returns an arrow along the path.  (See further info on paths in bezier_path).
 
@@ -357,7 +357,7 @@
 
     - ``headpoint`` - where the arrow is pointing to
 
-    - ``path`` - the list of points and control points (see bezier_path for detail) that 
+    - ``path`` - the list of points and control points (see bezier_path for detail) that
       the arrow will follow from source to destination
 
     - ``head`` - 0, 1 or 2, whether to draw the head at the start (0), end (1) or both (2)
@@ -375,7 +375,7 @@
     - ``arrowshorten`` - the length in points to shorten the arrow (ignored if using path
       parameter)
 
-    - ``legend_label`` - the label for this item in the legend 
+    - ``legend_label`` - the label for this item in the legend
 
     - ``zorder`` - the layer level to draw the arrow-- note that this is ignored in 3D
       plotting.
@@ -385,7 +385,7 @@
     A straight, blue arrow::
 
        sage: arrow2d((1, 1), (3, 3))
-    
+
     Make a red arrow::
 
        sage: arrow2d((-1, -1), (2, 3), color=(1,0,0))
@@ -406,16 +406,16 @@
         sage: line([(0,0),(1,0)],thickness=10)+line([(0,1),(1,1)], thickness=10)+arrow2d((0.5,0),(0.5,1), arrowshorten=10,rgbcolor=(1,0,0))
 
     If BOTH headpoint and tailpoint are None, then an empty plot is returned::
-    
+
         sage: arrow2d(headpoint=None, tailpoint=None)
-        
-    
+
+
     We can also draw an arrow with a legend::
 
         sage: arrow((0,0), (0,2), legend_label='up')
 
     Extra options will get passed on to show(), as long as they are valid::
- 
+
         sage: arrow2d((-2, 2), (7,1), frame=True)
         sage: arrow2d((-2, 2), (7,1)).show(frame=True)
     """
diff --git a/sage/plot/bar_chart.py b/sage/plot/bar_chart.py
--- a/sage/plot/bar_chart.py
+++ b/sage/plot/bar_chart.py
@@ -5,7 +5,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -32,28 +32,28 @@
 
         sage: from sage.plot.bar_chart import BarChart
         sage: g = BarChart(range(4), [1,3,2,0], {}); g
-        BarChart defined by a 4 datalist 
+        BarChart defined by a 4 datalist
         sage: type(g)
         <class 'sage.plot.bar_chart.BarChart'>
     """
     def __init__(self, ind, datalist, options):
         """
         Initialize a ``BarChart`` primitive.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.bar_chart import BarChart
             sage: BarChart(range(3), [10,3,5], {'width':0.7})
-            BarChart defined by a 3 datalist 
+            BarChart defined by a 3 datalist
         """
         self.datalist = datalist
         self.ind = ind
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: b = bar_chart([-2.3,5,-6,12])
@@ -70,7 +70,7 @@
         Return the allowed options with descriptions for this graphics
         primitive. This is used in displaying an error message when the
         user gives an option that doesn't make sense.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.bar_chart import BarChart
@@ -93,7 +93,7 @@
             sage: from sage.plot.bar_chart import BarChart
             sage: g = BarChart(range(4), [1,3,2,0], {})
             sage: g._repr_()
-            'BarChart defined by a 4 datalist'         
+            'BarChart defined by a 4 datalist'
         """
         return "BarChart defined by a %s datalist"%(len(self.datalist))
 
diff --git a/sage/plot/bezier_path.py b/sage/plot/bezier_path.py
--- a/sage/plot/bezier_path.py
+++ b/sage/plot/bezier_path.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #                     2009 Emily Kirkman
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
@@ -42,7 +42,7 @@
     def __init__(self, path, options):
         """
         Returns a graphics primitive of a path of Bezier curves.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.bezier_path import BezierPath
@@ -59,11 +59,11 @@
         self.codes = codes
         self.vertices = np.array(vertices, np.float)
         GraphicPrimitive_xydata.__init__(self, options)
-        
+
     def _allowed_options(self):
         """
         Returns a dict of allowed options for ``bezier_path``.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.bezier_path import BezierPath
@@ -82,13 +82,13 @@
                 'rgbcolor':'The color as an RGB tuple.',
                 'zorder':'The layer level in which to draw',
                 'linestyle':"The style of the line, which is one of 'dashed', 'dotted', 'solid', 'dashdot'."}
-    
+
     def _plot3d_options(self, options=None):
         """
         Updates ``BezierPath`` options to those allowed by 3D implementation.
-        
+
         EXAMPLES::
-        
+
             sage: from sage.plot.bezier_path import BezierPath
             sage: B = BezierPath([[(0,0),(.5,.5),(1,0)],[(.5,1),(0,0)]],{'linestyle':'dashed'})
             sage: B._plot3d_options()
@@ -118,19 +118,19 @@
 
     def plot3d(self, z=0, **kwds):
         """
-        Returns a 3D plot (Jmol) of the Bezier path.  Since a ``BezierPath`` 
-        primitive contains only `x,y` coordinates, the path will be drawn in 
-        some plane (default is `z=0`).  To create a Bezier path with nonzero 
-        (and nonidentical) `z` coordinates in the path and control points, use 
-        the function :func:`~sage.plot.plot3d.shapes2.bezier3d` instead of 
+        Returns a 3D plot (Jmol) of the Bezier path.  Since a ``BezierPath``
+        primitive contains only `x,y` coordinates, the path will be drawn in
+        some plane (default is `z=0`).  To create a Bezier path with nonzero
+        (and nonidentical) `z` coordinates in the path and control points, use
+        the function :func:`~sage.plot.plot3d.shapes2.bezier3d` instead of
         :func:`bezier_path`.
-        
+
         EXAMPLES::
 
             sage: b = bezier_path([[(0,0),(0,1),(1,0)]])
             sage: A = b.plot3d()
             sage: B = b.plot3d(z=2)
-            sage: A+B 
+            sage: A+B
 
         ::
 
@@ -140,7 +140,7 @@
         options = self._plot3d_options()
         options.update(kwds)
         return bezier3d([[(x,y,0) for x,y in self.path[i]] for i in range(len(self.path))], **options)
-                                        
+
     def _repr_(self):
         """
         Return text representation of this Bezier path graphics primitive.
@@ -150,10 +150,10 @@
             sage: from sage.plot.bezier_path import BezierPath
             sage: B = BezierPath([[(0,0),(.5,.5),(1,0)],[(.5,1),(0,0)]],{'linestyle':'dashed'})
             sage: B._repr_()
-            'Bezier path from (0, 0) to (0, 0)'       
+            'Bezier path from (0, 0) to (0, 0)'
         """
         return "Bezier path from %s to %s"%(self.path[0][0],self.path[-1][-1])
-        
+
     def _render_on_subplot(self, subplot):
         """
         Render this Bezier path in a subplot.  This is the key function that
@@ -168,17 +168,17 @@
 
             sage: bezier_path([[(0,1),(.5,0),(1,1),(-3,5)]])
         """
-        from matplotlib.patches import PathPatch  
+        from matplotlib.patches import PathPatch
         from matplotlib.path import Path
         options = dict(self.options())
-        
+
         del options['alpha']
         del options['thickness']
         del options['rgbcolor']
         del options['zorder']
         del options['fill']
         del options['linestyle']
-        
+
         bpath = Path(self.vertices, self.codes)
         bpatch = PathPatch(bpath, **options)
         options = self.options()
@@ -196,7 +196,7 @@
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: b = bezier_path([[(0,0),(.5,.5),(1,0)],[(.5,1),(0,0)]])
@@ -218,32 +218,32 @@
     Returns a Graphics object of a Bezier path corresponding to the
     path parameter.  The path is a list of curves, and each curve is
     a list of points.  Each point is a tuple ``(x,y)``.
-    
-    The first curve contains the endpoints as the first and last point 
+
+    The first curve contains the endpoints as the first and last point
     in the list.  All other curves assume a starting point given by the
     last entry in the preceding list, and take the last point in the list
     as their opposite endpoint.  A curve can have 0, 1 or 2 control points
-    listed between the endpoints.  In the input example for path below, 
+    listed between the endpoints.  In the input example for path below,
     the first and second curves have 2 control points, the third has one,
-    and the fourth has no control points:    
-    
+    and the fourth has no control points:
+
     path = [[p1, c1, c2, p2], [c3, c4, p3], [c5, p4], [p5], ...]
-    
+
     In the case of no control points, a straight line will be drawn
-    between the two endpoints.  If one control point is supplied, then 
+    between the two endpoints.  If one control point is supplied, then
     the curve at each of the endpoints will be tangent to the line from
-    that endpoint to the control point.  Similarly, in the case of two 
+    that endpoint to the control point.  Similarly, in the case of two
     control points, at each endpoint the curve will be tangent to the line
     connecting that endpoint with the control point immediately after or
     immediately preceding it in the list.
-    
+
     So in our example above, the curve between p1 and p2 is tangent to the
     line through p1 and c1 at p1, and tangent to the line through p2 and c2
     at p2.  Similarly, the curve between p2 and p3 is tangent to line(p2,c3)
-    at p2 and tangent to line(p3,c4) at p3.  Curve(p3,p4) is tangent to 
+    at p2 and tangent to line(p3,c4) at p3.  Curve(p3,p4) is tangent to
     line(p3,c5) at p3 and tangent to line(p4,c5) at p4.  Curve(p4,p5) is a
     straight line.
-    
+
     INPUT:
 
     - ``path`` -- a list of lists of tuples (see above)
@@ -253,7 +253,7 @@
     - ``linestyle`` -- default: 'solid'
     - ``rbgcolor`` -- default: (0,0,0)
     - ``zorder`` -- the layer in which to draw
-        
+
     EXAMPLES::
 
         sage: path = [[(0,0),(.5,.1),(.75,3),(1,0)],[(.5,1),(.5,0)],[(.2,.5)]]
@@ -261,7 +261,7 @@
         sage: b
 
     To construct a simple curve, create a list containing a single list::
-        
+
         sage: path = [[(0,0),(.5,1),(1,0)]]
         sage: curve = bezier_path(path, linestyle='dashed', rgbcolor='green')
         sage: curve
@@ -276,4 +276,4 @@
     g._set_extra_kwds(g._extract_kwds_for_show(options))
     g.add_primitive(BezierPath(path, options))
     return g
-    
+
diff --git a/sage/plot/circle.py b/sage/plot/circle.py
--- a/sage/plot/circle.py
+++ b/sage/plot/circle.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -75,12 +75,12 @@
         self.x = float(x)
         self.y = float(y)
         self.r = float(r)
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: p = circle((3, 3), 1)
@@ -135,9 +135,9 @@
         """
         TESTS::
 
-            sage: C = circle((2,pi), 2, edgecolor='black', facecolor='green', fill=True) 
+            sage: C = circle((2,pi), 2, edgecolor='black', facecolor='green', fill=True)
         """
-        import matplotlib.patches as patches        
+        import matplotlib.patches as patches
         options = self.options()
         p = patches.Circle((float(self.x), float(self.y)), float(self.r), clip_on=options['clip'])
         if not options['clip']:
@@ -148,7 +148,7 @@
         p.set_alpha(a)
         ec = to_mpl_color(options['edgecolor'])
         fc = to_mpl_color(options['facecolor'])
-        if 'rgbcolor' in options: 
+        if 'rgbcolor' in options:
             ec = fc = to_mpl_color(options['rgbcolor'])
         p.set_edgecolor(ec)
         p.set_facecolor(fc)
@@ -160,19 +160,19 @@
 
     def plot3d(self, z=0, **kwds):
         """
-        Plots a 2D circle (actually a 50-gon) in 3D, 
+        Plots a 2D circle (actually a 50-gon) in 3D,
         with default height zero.
 
         INPUT:
-    
-    
-        -  ``z`` - optional 3D height above `xy`-plane.  
 
-        EXAMPLES: 
+
+        -  ``z`` - optional 3D height above `xy`-plane.
+
+        EXAMPLES:
 
             sage: circle((0,0), 1).plot3d()
 
-        This example uses this method implicitly, but does not pass 
+        This example uses this method implicitly, but does not pass
         the optional parameter z to this method::
 
             sage: sum([circle((random(),random()), random()).plot3d(z=random()) for _ in range(20)])
@@ -213,14 +213,14 @@
             return Line(xdata, ydata, options).plot3d().translate((0,0,z))
 
 @rename_keyword(color='rgbcolor')
-@options(alpha=1, fill=False, thickness=1, edgecolor='black', facecolor='red', linestyle='solid', 
+@options(alpha=1, fill=False, thickness=1, edgecolor='black', facecolor='red', linestyle='solid',
          zorder=5, legend_label=None, clip=True, aspect_ratio=1.0)
 def circle(center, radius, **options):
     """
-    Return a circle at a point center = `(x,y)` (or `(x,y,z)` and 
-    parallel to the `xy`-plane) with radius = `r`.  Type 
+    Return a circle at a point center = `(x,y)` (or `(x,y,z)` and
+    parallel to the `xy`-plane) with radius = `r`.  Type
     ``circle.options`` to see all options.
-    
+
     OPTIONS:
 
     - ``alpha`` - default: 1
diff --git a/sage/plot/colors.py b/sage/plot/colors.py
--- a/sage/plot/colors.py
+++ b/sage/plot/colors.py
@@ -1032,7 +1032,7 @@
         RGB color (0.2549019607843137, 0.4117647058823529, 0.8823529411764706)
         sage: hue(*royalblue.hsv())
         (0.2549019607843137, 0.4117647058823529, 0.8823529411764706)
-        sage: hue(.5, .5, .5) 
+        sage: hue(.5, .5, .5)
         (0.25, 0.5, 0.5)
 
     .. note :: The HSV to RGB coordinate transformation itself is
@@ -1239,7 +1239,7 @@
             0
             sage: maps.load_maps()
             sage: len(maps.maps)>130
-            True 
+            True
         """
         global cm
         if not cm:
diff --git a/sage/plot/contour_plot.py b/sage/plot/contour_plot.py
--- a/sage/plot/contour_plot.py
+++ b/sage/plot/contour_plot.py
@@ -5,7 +5,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -26,7 +26,7 @@
 
 class ContourPlot(GraphicPrimitive):
     """
-    Primitive class for the contour plot graphics type.  See 
+    Primitive class for the contour plot graphics type.  See
     ``contour_plot?`` for help actually doing contour plots.
 
     INPUT:
@@ -60,7 +60,7 @@
     def __init__(self, xy_data_array, xrange, yrange, options):
         """
         Initializes base class ContourPlot.
-        
+
         EXAMPLES::
 
             sage: x,y = var('x,y')
@@ -75,12 +75,12 @@
         self.xy_data_array = xy_data_array
         self.xy_array_row = len(xy_data_array)
         self.xy_array_col = len(xy_data_array[0])
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: x,y = var('x,y')
@@ -106,15 +106,15 @@
             True
         """
         return {'plot_points':'How many points to use for plotting precision',
-                'cmap':"""the name of a predefined colormap, 
-                        a list of colors, or an instance of a 
+                'cmap':"""the name of a predefined colormap,
+                        a list of colors, or an instance of a
                         matplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()
-                        for available colormap names.""", 
+                        for available colormap names.""",
                 'colorbar': "Include a colorbar indicating the levels",
                 'colorbar_options': "a dictionary of options for colorbars",
                 'fill':'Fill contours or not',
                 'legend_label':'The label for this item in the legend.',
-                'contours':"""Either an integer specifying the number of 
+                'contours':"""Either an integer specifying the number of
                         contour levels, or a sequence of numbers giving
                         the actual contours to use.""",
                 'linewidths':'the width of the lines to be plotted',
@@ -205,9 +205,9 @@
 @suboptions('label', fontsize=9, colors='blue', inline=None, inline_spacing=3, fmt="%1.2f")
 @options(plot_points=100, fill=True, contours=None, linewidths=None, linestyles=None, labels=False, frame=True, axes=False, colorbar=False, legend_label=None, aspect_ratio=1)
 def contour_plot(f, xrange, yrange, **options):
-    r"""    
+    r"""
     ``contour_plot`` takes a function of two variables, `f(x,y)`
-    and plots contour lines of the function over the specified 
+    and plots contour lines of the function over the specified
     ``xrange`` and ``yrange`` as demonstrated below.
 
     ``contour_plot(f, (xmin, xmax), (ymin, ymax), ...)``
@@ -225,7 +225,7 @@
     The following inputs must all be passed in as named parameters:
 
     - ``plot_points``  -- integer (default: 100); number of points to plot
-      in each direction of the grid.  For old computers, 25 is fine, but 
+      in each direction of the grid.  For old computers, 25 is fine, but
       should not be used to verify specific intersection points.
 
     - ``fill`` -- bool (default: ``True``), whether to color in the area
@@ -255,7 +255,7 @@
       contours, then the styles will be repeated cyclically.
 
     - ``labels`` -- boolean (default: False) Show level labels or not.
- 
+
       The following options are to adjust the style and placement of
       labels, they have no effect if no labels are shown.
 
@@ -282,7 +282,7 @@
         returns a string when called with a numeric contour level.
 
     - ``colorbar`` -- boolean (default: False) Show a colorbar or not.
-    
+
       The following options are to adjust the style and placement of
       colorbars.  They have no effect if a colorbar is not shown.
 
@@ -308,12 +308,12 @@
 
         sage: x,y = var('x,y')
         sage: contour_plot(cos(x^2+y^2), (x, -4, 4), (y, -4, 4))
-         
+
     Here we change the ranges and add some options::
 
         sage: x,y = var('x,y')
         sage: contour_plot((x^2)*cos(x*y), (x, -10, 5), (y, -5, 5), fill=False, plot_points=150)
-        
+
     An even more complicated plot::
 
         sage: x,y = var('x,y')
@@ -339,7 +339,7 @@
     ::
 
         sage: contour_plot(f, (-2, 2), (-2, 2), contours=2, cmap=[(1,0,0), (0,1,0), (0,0,1)])
- 
+
     ::
 
         sage: contour_plot(f, (-2, 2), (-2, 2), contours=(0.1, 1.0, 1.2, 1.4), cmap='hsv')
@@ -412,7 +412,7 @@
         sage: P= contour_plot(y^2 + 1 - x^3 - x, (x,-pi,pi), (y,-pi,pi), \
         ...    fill=False, cmap='hsv', labels=True, label_inline=False)
         sage: P
-    
+
     We can change the color of the labels if so desired::
 
         sage: contour_plot(f, (-2,2), (-2,2), labels=True, label_colors='red')
@@ -460,11 +460,11 @@
 
         sage: contour_plot(f, (0, pi), (0, pi)).show(axes=True) # These are equivalent
 
-    Note that with ``fill=False`` and grayscale contours, there is the 
+    Note that with ``fill=False`` and grayscale contours, there is the
     possibility of confusion between the contours and the axes, so use
     ``fill=False`` together with ``axes=True`` with caution::
 
-        sage: contour_plot(f, (-pi, pi), (-pi, pi), fill=False, axes=True) 
+        sage: contour_plot(f, (-pi, pi), (-pi, pi), fill=False, axes=True)
 
     TESTS:
 
@@ -478,20 +478,20 @@
     g, ranges = setup_for_eval_on_grid([f], [xrange, yrange], options['plot_points'])
     g = g[0]
     xrange,yrange=[r[:2] for r in ranges]
-    
+
     xy_data_array = [[g(x, y) for x in xsrange(*ranges[0], include_endpoint=True)]
                               for y in xsrange(*ranges[1], include_endpoint=True)]
 
     g = Graphics()
     g._set_extra_kwds(Graphics._extract_kwds_for_show(options, ignore=['xmin', 'xmax']))
     g.add_primitive(ContourPlot(xy_data_array, xrange, yrange, options))
-    return g        
+    return g
 
 @options(plot_points=150, contours=(0,0), fill=False, cmap=["blue"])
 def implicit_plot(f, xrange, yrange, **options):
     r"""
     ``implicit_plot`` takes a function of two variables, `f(x,y)`
-    and plots the curve `f(x,y) = 0` over the specified 
+    and plots the curve `f(x,y) = 0` over the specified
     ``xrange`` and ``yrange`` as demonstrated below.
 
     ``implicit_plot(f, (xmin, xmax), (ymin, ymax), ...)``
@@ -513,14 +513,14 @@
 
     - ``fill`` -- boolean (default: ``False``); if ``True``, fill the region
       `f(x,y) < 0`.
-        
-    - ``linewidth`` -- integer (default: None), if a single integer all levels 
-      will be of the width given, otherwise the levels will be plotted with the 
+
+    - ``linewidth`` -- integer (default: None), if a single integer all levels
+      will be of the width given, otherwise the levels will be plotted with the
       widths in the order given.
 
-    - ``linestyle`` -- string (default: None), the style of the line to be 
+    - ``linestyle`` -- string (default: None), the style of the line to be
       plotted, one of: solid, dashed, dashdot or dotted.
-      
+
     - ``color`` -- string (default: ``blue``), the color of the plot. Colors are
       defined in :mod:`sage.plot.colors`; try ``colors?`` to see them all.
 
@@ -555,12 +555,12 @@
         sage: var("x y")
         (x, y)
         sage: implicit_plot(x^2+y^2 == 2, (x,-3,3), (y,-3,3))
-        
+
     You can even change the color of the plot::
-    
+
         sage: implicit_plot(x^2+y^2 == 2, (x,-3,3), (y,-3,3), color="red")
 
-    Here is a beautiful (and long) example which also tests that all 
+    Here is a beautiful (and long) example which also tests that all
     colors work with this::
 
         sage: G = Graphics()
@@ -570,7 +570,7 @@
         ...       counter += 1
         sage: G.show(frame=False)
 
-    We can define a level-`n` approximation of the boundary of the 
+    We can define a level-`n` approximation of the boundary of the
     Mandelbrot set::
 
         sage: def mandel(n):
@@ -586,12 +586,12 @@
     The first-level approximation is just a circle::
 
         sage: implicit_plot(mandel(1), (-3, 3), (-3, 3))
-        
+
     A third-level approximation starts to get interesting::
 
         sage: implicit_plot(mandel(3), (-2, 1), (-1.5, 1.5))
 
-    The seventh-level approximation is a degree 64 polynomial, and 
+    The seventh-level approximation is a degree 64 polynomial, and
     ``implicit_plot`` does a pretty good job on this part of the curve.
     (``plot_points=200`` looks even better, but it takes over a second.)
 
@@ -647,7 +647,7 @@
 def region_plot(f, xrange, yrange, plot_points, incol, outcol, bordercol, borderstyle, borderwidth,**options):
     r"""
     ``region_plot`` takes a boolean function of two variables, `f(x,y)`
-    and plots the region where f is True over the specified 
+    and plots the region where f is True over the specified
     ``xrange`` and ``yrange`` as demonstrated below.
 
     ``region_plot(f, (xmin, xmax), (ymin, ymax), ...)``
@@ -671,7 +671,7 @@
       of the region
 
     If any of these options are specified, the border will be shown as indicated,
-    otherwise it is only implicit (with color ``incol``) as the border of the 
+    otherwise it is only implicit (with color ``incol``) as the border of the
     inside of the region.
 
      - ``bordercol`` -- a color (default: ``None``), the color of the border
@@ -680,7 +680,7 @@
     - ``borderstyle``  -- string (default: 'solid'), one of 'solid', 'dashed', 'dotted', 'dashdot'
 
     - ``borderwidth``  -- integer (default: None), the width of the border in pixels
- 
+
     - ``legend_label`` -- the label for this item in the legend
 
 
@@ -690,11 +690,11 @@
 
         sage: x,y = var('x,y')
         sage: region_plot(cos(x^2+y^2) <= 0, (x, -3, 3), (y, -3, 3))
-         
+
     Here we play with the colors::
 
         sage: region_plot(x^2+y^3 < 2, (x, -2, 2), (y, -2, 2), incol='lightblue', bordercol='gray')
-        
+
     An even more complicated plot, with dashed borders::
 
         sage: region_plot(sin(x)*sin(y) >= 1/4, (x,-10,10), (y,-10,10), incol='yellow', bordercol='black', borderstyle='dashed', plot_points=250)
@@ -715,7 +715,7 @@
     Using lambda functions, we definitely need the extra ``plot_points``::
 
         sage: region_plot(lambda x,y: x^2+y^2<1 or x<y, (x,-2,2), (y,-2,2), plot_points=400)
-    
+
     The first quadrant of the unit circle::
 
         sage: region_plot([y>0, x>0, x^2+y^2<1], (x,-1.1, 1.1), (y,-1.1, 1.1), plot_points = 400)
@@ -771,29 +771,29 @@
     cmap = ListedColormap([incol, outcol])
     cmap.set_over(outcol)
     cmap.set_under(incol)
-    
+
     g = Graphics()
     g._set_extra_kwds(Graphics._extract_kwds_for_show(options, ignore=['xmin', 'xmax']))
-    g.add_primitive(ContourPlot(xy_data_array, xrange,yrange, 
+    g.add_primitive(ContourPlot(xy_data_array, xrange,yrange,
                                 dict(contours=[-1e307, 0, 1e307], cmap=cmap, fill=True, **options)))
 
     if bordercol or borderstyle or borderwidth:
         cmap = [rgbcolor(bordercol)] if bordercol else ['black']
         linestyles = [borderstyle] if borderstyle else None
         linewidths = [borderwidth] if borderwidth else None
-        g.add_primitive(ContourPlot(xy_data_array, xrange, yrange, 
+        g.add_primitive(ContourPlot(xy_data_array, xrange, yrange,
                                     dict(linestyles=linestyles, linewidths=linewidths,
                                          contours=[0], cmap=[bordercol], fill=False, **options)))
-    
+
     return g
 
 def equify(f):
     """
     Returns the equation rewritten as a symbolic function to give
     negative values when True, positive when False.
-    
+
     EXAMPLES::
-    
+
         sage: from sage.plot.contour_plot import equify
         sage: var('x, y')
         (x, y)
diff --git a/sage/plot/density_plot.py b/sage/plot/density_plot.py
--- a/sage/plot/density_plot.py
+++ b/sage/plot/density_plot.py
@@ -83,7 +83,7 @@
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: x,y = var('x,y')
@@ -137,17 +137,17 @@
         """
         options = self.options()
         cmap = get_cmap(options['cmap'])
-        
+
         x0,x1 = float(self.xrange[0]), float(self.xrange[1])
         y0,y1 = float(self.yrange[0]), float(self.yrange[1])
-        
+
         subplot.imshow(self.xy_data_array, origin='lower', cmap=cmap, extent=(x0,x1,y0,y1), interpolation=options['interpolation'])
 
 @options(plot_points=25, cmap='gray', interpolation='catrom')
 def density_plot(f, xrange, yrange, **options):
-    r"""    
+    r"""
     ``density_plot`` takes a function of two variables, `f(x,y)`
-    and plots the height of of the function over the specified 
+    and plots the height of of the function over the specified
     ``xrange`` and ``yrange`` as demonstrated below.
 
     ``density_plot(f, (xmin, xmax), (ymin, ymax), ...)``
@@ -174,7 +174,7 @@
       ``'spline36'``, ``'quadric'``, ``'gaussian'``, ``'sinc'``,
       ``'bessel'``, ``'mitchell'``, ``'lanczos'``, ``'catrom'``,
       ``'hermite'``, ``'hanning'``, ``'hamming'``, ``'kaiser'``
-        
+
 
     EXAMPLES:
 
@@ -184,25 +184,25 @@
 
         sage: x,y = var('x,y')
         sage: density_plot(sin(x)*sin(y), (x, -2, 2), (y, -2, 2))
-        
-        
+
+
     Here we change the ranges and add some options; note that here
     ``f`` is callable (has variables declared), so we can use 2-tuple ranges::
 
         sage: x,y = var('x,y')
         sage: f(x,y) = x^2*cos(x*y)
         sage: density_plot(f, (x,-10,5), (y, -5,5), interpolation='sinc', plot_points=100)
-        
+
     An even more complicated plot::
 
         sage: x,y = var('x,y')
         sage: density_plot(sin(x^2 + y^2)*cos(x)*sin(y), (x, -4, 4), (y, -4, 4), cmap='jet', plot_points=100)
-        
+
     This should show a "spotlight" right on the origin::
 
-        sage: x,y = var('x,y') 
-        sage: density_plot(1/(x^10+y^10), (x, -10, 10), (y, -10, 10)) 
-        
+        sage: x,y = var('x,y')
+        sage: density_plot(1/(x^10+y^10), (x, -10, 10), (y, -10, 10))
+
     Some elliptic curves, but with symbolic endpoints.  In the first
     example, the plot is rotated 90 degrees because we switch the
     variables `x`, `y`::
diff --git a/sage/plot/disk.py b/sage/plot/disk.py
--- a/sage/plot/disk.py
+++ b/sage/plot/disk.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -25,7 +25,7 @@
 class Disk(GraphicPrimitive):
     """
     Primitive class for the ``Disk`` graphics type.  See ``disk?`` for
-    information about actually plotting a disk (the Sage term for a sector 
+    information about actually plotting a disk (the Sage term for a sector
     or wedge of a circle).
 
     INPUT:
@@ -34,7 +34,7 @@
 
     - ``r`` - radius of disk
 
-    - ``angle`` - beginning and ending angles of disk (i.e. 
+    - ``angle`` - beginning and ending angles of disk (i.e.
       angle extent of sector/wedge)
 
     - ``options`` - dict of valid plot options to pass to constructor
@@ -83,7 +83,7 @@
         self.r = float(r)
         self.rad1 = float(angle[0])
         self.rad2 = float(angle[1])
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
@@ -101,7 +101,7 @@
             6.0
             sage: d['ymax']
             5.0
-      
+
         """
         from sage.plot.plot import minmax_data
         return minmax_data([self.x - self.r, self.x + self.r],
@@ -147,9 +147,9 @@
 
             sage: D = disk((2,-1), 2, (0, pi), color='black', thickness=3, fill=False); D
         """
-        import matplotlib.patches as patches        
+        import matplotlib.patches as patches
         options = self.options()
-        deg1 = self.rad1*(180./pi) #convert radians to degrees 
+        deg1 = self.rad1*(180./pi) #convert radians to degrees
         deg2 = self.rad2*(180./pi)
         z = int(options.pop('zorder', 0))
         p = patches.Wedge((float(self.x), float(self.y)), float(self.r), float(deg1),
@@ -165,13 +165,13 @@
 
     def plot3d(self, z=0, **kwds):
         """
-        Plots a 2D disk (actually a 52-gon) in 3D, 
+        Plots a 2D disk (actually a 52-gon) in 3D,
         with default height zero.
 
         INPUT:
-    
-    
-        -  ``z`` - optional 3D height above `xy`-plane.  
+
+
+        -  ``z`` - optional 3D height above `xy`-plane.
 
         AUTHORS:
 
@@ -220,13 +220,13 @@
             return Line(xdata, ydata, options).plot3d().translate((0,0,z))
 
 @rename_keyword(color='rgbcolor')
-@options(alpha=1, fill=True, rgbcolor=(0,0,1), thickness=0, legend_label=None, 
+@options(alpha=1, fill=True, rgbcolor=(0,0,1), thickness=0, legend_label=None,
          aspect_ratio=1.0)
 def disk(point, radius, angle, **options):
     r"""
     A disk (that is, a sector or wedge of a circle) with center
-    at a point = `(x,y)` (or `(x,y,z)` and parallel to the 
-    `xy`-plane) with radius = `r` spanning (in radians) 
+    at a point = `(x,y)` (or `(x,y,z)` and parallel to the
+    `xy`-plane) with radius = `r` spanning (in radians)
     angle=`(rad1, rad2)`.
 
     Type ``disk.options`` to see all options.
@@ -234,7 +234,7 @@
     EXAMPLES:
 
     Make some dangerous disks::
-    
+
         sage: bl = disk((0.0,0.0), 1, (pi, 3*pi/2), color='yellow')
         sage: tr = disk((0.0,0.0), 1, (0, pi/2), color='yellow')
         sage: tl = disk((0.0,0.0), 1, (pi/2, pi), color='black')
diff --git a/sage/plot/ellipse.py b/sage/plot/ellipse.py
--- a/sage/plot/ellipse.py
+++ b/sage/plot/ellipse.py
@@ -22,7 +22,7 @@
 
 class Ellipse(GraphicPrimitive):
     """
-    Primitive class for the ``Ellipse`` graphics type.  See ``ellipse?`` for 
+    Primitive class for the ``Ellipse`` graphics type.  See ``ellipse?`` for
     information about actually plotting ellipses.
 
     INPUT:
@@ -66,14 +66,14 @@
             raise ValueError, "both radii must be positive"
         self.angle = fmod(angle,2*pi)
         if self.angle < 0: self.angle += 2*pi
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
 
         The bounding box is computed to be as minimal as possible.
-    
+
         EXAMPLES:
 
         An example without an angle::
@@ -124,7 +124,7 @@
             ymax = (
                 abs(self.r1 * sin_angle / sqrt(symax+1.)) +
                 abs(self.r2 * cos_angle / sqrt(1./symax+1.)))
-            
+
         return minmax_data([self.x - xmax, self.x + xmax],
                            [self.y - ymax, self.y + ymax],
                            dict=True)
@@ -177,7 +177,7 @@
 
             sage: ellipse((3,2),1,2)
         """
-        import matplotlib.patches as patches        
+        import matplotlib.patches as patches
         options = self.options()
         p = patches.Ellipse(
                 (self.x,self.y),
@@ -188,7 +188,7 @@
         p.set_alpha(a)
         ec = to_mpl_color(options['edgecolor'])
         fc = to_mpl_color(options['facecolor'])
-        if 'rgbcolor' in options: 
+        if 'rgbcolor' in options:
             ec = fc = to_mpl_color(options['rgbcolor'])
         p.set_edgecolor(ec)
         p.set_facecolor(fc)
@@ -202,7 +202,7 @@
         Plotting in 3D is not implemented.
 
         TESTS::
-            
+
             sage: from sage.plot.ellipse import Ellipse
             sage: Ellipse(0,0,2,1,pi/4,{}).plot3d()
             Traceback (most recent call last):
@@ -228,7 +228,7 @@
 
     - ``angle`` - real number (default: 0) - the angle between the first axis
       and the horizontal
-    
+
     OPTIONS:
 
     - ``alpha`` - default: 1 - transparency
@@ -237,7 +237,7 @@
 
     - ``thickness`` - default: 1 - thickness of the line
 
-    - ``rgbcolor`` - default: (0,0,0) - color of the ellipse 
+    - ``rgbcolor`` - default: (0,0,0) - color of the ellipse
       (overwrites ``edgecolor`` and ``facecolor``)
 
     - ``linestyle`` - default: 'solid'
diff --git a/sage/plot/graphics.py b/sage/plot/graphics.py
--- a/sage/plot/graphics.py
+++ b/sage/plot/graphics.py
@@ -39,35 +39,35 @@
     r"""
     Set the default for showing plots using any plot commands. If
     called with no arguments, returns the current default.
-    
+
     If this is ``True`` (the default) then any plot object
     when displayed will be displayed as an actual plot instead of text,
     i.e., the show command is not needed.
-    
+
     EXAMPLES: The default starts out as ``True``::
-    
+
         sage: show_default()
         True
-    
+
     We set it to ``False``.
-    
+
     ::
-    
+
         sage: show_default(False)
-    
+
     We see that it is ``False``.
-    
+
     ::
-    
+
         sage: show_default()
         False
-    
+
     Now plot commands will not display their plots by default.
-    
+
     Turn back on default display.
-    
+
     ::
-    
+
         sage: show_default(True)
     """
     global SHOW_DEFAULT
@@ -82,9 +82,9 @@
 def is_Graphics(x):
     """
     Return True if `x` is a Graphics object.
-    
+
     EXAMPLES::
-    
+
         sage: from sage.plot.graphics import is_Graphics
         sage: is_Graphics(1)
         False
@@ -98,18 +98,18 @@
     The Graphics object is an empty list of graphics objects It is
     useful to use this object when initializing a for loop where
     different graphics object will be added to the empty object.
-    
+
     EXAMPLES::
-    
+
         sage: G = Graphics(); print G
         Graphics object consisting of 0 graphics primitives
         sage: c = circle((1,1), 1)
         sage: G+=c; print G
         Graphics object consisting of 1 graphics primitive
-    
+
     Here we make a graphic of embedded isosceles triangles, coloring
     each one with a different color as we go::
-    
+
         sage: h=10; c=0.4; p=0.5;
         sage: G = Graphics()
         sage: for x in srange(1,h+1):
@@ -142,9 +142,9 @@
     def __init__(self):
         """
         Create a new empty Graphics objects with all the defaults.
-        
+
         EXAMPLES::
-        
+
             sage: G = Graphics()
         """
         self._axes_color = (0, 0, 0)
@@ -164,34 +164,34 @@
         Set the aspect ratio, which is the ratio of height and width
         of a unit square (i.e., height/width of a unit square), or
         'automatic' (expand to fill the figure).
-        
+
         INPUT:
-        
-        
+
+
         -  ``ratio`` - a positive real number or 'automatic'
-        
-        
+
+
         EXAMPLES: We create a plot of the upper half of a circle, but it
         doesn't look round because the aspect ratio is off::
-        
+
             sage: P = plot(sqrt(1-x^2),(x,-1,1)); P
-        
+
         So we set the aspect ratio and now it is round::
-        
+
             sage: P.set_aspect_ratio(1)
             sage: P.aspect_ratio()
             1.0
             sage: P
-        
+
         Note that the aspect ratio is inherited upon addition (which takes
         the max of aspect ratios of objects whose aspect ratio has been
         set)::
-        
+
             sage: P + plot(sqrt(4-x^2),(x,-2,2))
-        
+
         In the following example, both plots produce a circle that looks
         twice as tall as wide::
-        
+
             sage: Q = circle((0,0), 0.5); Q.set_aspect_ratio(2)
             sage: (P + Q).aspect_ratio(); P+Q
             2.0
@@ -210,12 +210,12 @@
         """
         Get the current aspect ratio, which is the ratio of height to
         width of a unit square, or 'automatic'.
-        
+
         OUTPUT: a positive float (height/width of a unit square), or 'automatic'
         (expand to fill the figure).
-        
+
         EXAMPLES:
-        
+
         The default aspect ratio for a new blank Graphics object is 'automatic'::
 
             sage: P = Graphics()
@@ -239,13 +239,13 @@
     def legend(self, show=None):
         r"""
         Set whether or not the legend is shown by default.
-        
+
         INPUT:
 
         -  ``show`` - (default: None) a boolean
-        
+
         If called with no input, return the current legend setting.
-        
+
         EXAMPLES:
 
         By default no legend is displayed::
@@ -253,7 +253,7 @@
             sage: P = plot(sin)
             sage: P.legend()
             False
-            
+
         But if we put a label then the legend is shown::
 
             sage: P = plot(sin, legend_label='sin')
@@ -276,7 +276,7 @@
     def set_legend_options(self, **kwds):
         r"""
         Set various legend options.
-        
+
         INPUT:
 
         - ``title`` - (default: None) string, the legend title
@@ -354,9 +354,9 @@
           fancybox.
 
         These are all keyword arguments.
-        
+
         OUTPUT: a dictionary of all current legend options
-            
+
         EXAMPLES:
 
         By default, no options are set::
@@ -364,13 +364,13 @@
             sage: p = plot(tan, legend_label='tan')
             sage: p.set_legend_options()
             {}
-        
+
         We build a legend with a shadow::
 
             sage: p.set_legend_options(shadow=True)
             sage: p.set_legend_options()['shadow']
             True
-        
+
         To set the legend position to the center of the plot, all these
         methods are roughly equivalent::
 
@@ -388,7 +388,7 @@
             return self._legend_opts
         else:
             self._legend_opts.update(kwds)
-    
+
 
     def get_axes_range(self):
         """
@@ -418,15 +418,15 @@
     def set_axes_range(self, xmin=None, xmax=None, ymin=None, ymax=None):
         """
         Set the ranges of the `x` and `y` axes.
-        
+
         INPUT:
-        
-        
+
+
         -  ``xmin, xmax, ymin, ymax`` - floats
-        
-        
+
+
         EXAMPLES::
-        
+
             sage: L = line([(1,2), (3,-4), (2, 5), (1,2)])
             sage: L.set_axes_range(-1, 20, 0, 2)
             sage: d = L.get_axes_range()
@@ -464,26 +464,26 @@
     def fontsize(self, s=None):
         """
         Set the font size of axes labels and tick marks.
-        
+
         INPUT:
-        
-        
+
+
         -  ``s`` - integer, a font size in points.
-        
-        
+
+
         If called with no input, return the current fontsize.
-        
+
         EXAMPLES::
-        
+
             sage: L = line([(1,2), (3,-4), (2, 5), (1,2)])
             sage: L.fontsize()
             10
             sage: L.fontsize(20)
             sage: L.fontsize()
             20
-        
+
         All the numbers on the axes will be very large in this plot::
-        
+
             sage: L
         """
         if s is None:
@@ -498,38 +498,38 @@
         """
         Set whether or not the `x` and `y` axes are shown
         by default.
-        
+
         INPUT:
-        
-        
+
+
         -  ``show`` - bool
-        
-        
+
+
         If called with no input, return the current axes setting.
-        
+
         EXAMPLES::
-        
+
             sage: L = line([(1,2), (3,-4), (2, 5), (1,2)])
-        
+
         By default the axes are displayed.
-        
+
         ::
-        
+
             sage: L.axes()
             True
-        
+
         But we turn them off, and verify that they are off
-        
+
         ::
-        
+
             sage: L.axes(False)
             sage: L.axes()
             False
-        
+
         Displaying L now shows a triangle but no axes.
-        
+
         ::
-        
+
             sage: L
         """
         if show is None:
@@ -543,44 +543,44 @@
     def axes_color(self, c=None):
         """
         Set the axes color.
-        
+
         If called with no input, return the current axes_color setting.
-        
+
         INPUT:
-        
-        
+
+
         -  ``c`` - an RGB color 3-tuple, where each tuple entry
            is a float between 0 and 1
-        
-        
+
+
         EXAMPLES: We create a line, which has like everything a default
         axes color of black.
-        
+
         ::
-        
+
             sage: L = line([(1,2), (3,-4), (2, 5), (1,2)])
             sage: L.axes_color()
             (0, 0, 0)
-        
+
         We change the axes color to red and verify the change.
-        
+
         ::
-        
+
             sage: L.axes_color((1,0,0))
             sage: L.axes_color()
             (1.0, 0.0, 0.0)
-        
+
         When we display the plot, we'll see a blue triangle and bright red
         axes.
-        
+
         ::
-        
+
             sage: L
         """
         if c is None:
             try:
                 return self._axes_color
-            
+
             except AttributeError:
                 self._axes_color = (0.0, 0.0, 0.0)
                 return self._axes_color
@@ -589,31 +589,31 @@
     def axes_labels(self, l=None):
         """
         Set the axes labels.
-        
+
         INPUT:
-        
-        
+
+
         -  ``l`` - (default: None) a list of two strings or
            None
-        
-        
+
+
         OUTPUT: a 2-tuple of strings
-        
+
         If l is None, returns the current ``axes_labels``,
         which is itself by default None. The default labels are both
         empty.
-        
+
         EXAMPLES: We create a plot and put x and y axes labels on it.
-        
+
         ::
-        
+
             sage: p = plot(sin(x), (x, 0, 10))
             sage: p.axes_labels(['$x$','$y$'])
             sage: p.axes_labels()
             ('$x$', '$y$')
-        
+
         Now when you plot p, you see x and y axes labels::
-        
+
             sage: p
 
         Notice that some may prefer axes labels which are not
@@ -636,44 +636,44 @@
     def axes_label_color(self, c=None):
         r"""
         Set the color of the axes labels.
-        
+
         The axes labels are placed at the edge of the x and y axes, and are
         not on by default (use the ``axes_labels`` command to
         set them; see the example below). This function just changes their
         color.
-        
+
         INPUT:
-        
-        
+
+
         -  ``c`` - an RGB 3-tuple of numbers between 0 and 1
-        
-        
+
+
         If called with no input, return the current axes_label_color
         setting.
-        
+
         EXAMPLES: We create a plot, which by default has axes label color
         black.
-        
+
         ::
-        
+
             sage: p = plot(sin, (-1,1))
             sage: p.axes_label_color()
             (0, 0, 0)
-        
+
         We change the labels to be red, and confirm this::
-        
+
             sage: p.axes_label_color((1,0,0))
             sage: p.axes_label_color()
             (1.0, 0.0, 0.0)
-        
+
         We set labels, since otherwise we won't see anything.
-        
+
         ::
-        
+
             sage: p.axes_labels(['$x$ axis', '$y$ axis'])
-        
+
         In the plot below, notice that the labels are red::
-        
+
             sage: p
         """
         if c is None:
@@ -689,32 +689,32 @@
         r"""
         Set the axes width. Use this to draw a plot with really fat or
         really thin axes.
-        
+
         INPUT:
-        
-        
+
+
         -  ``w`` - a float
-        
-        
+
+
         If called with no input, return the current
         ``axes_width`` setting.
-        
+
         EXAMPLE: We create a plot, see the default axes width (with funny
         Python float rounding), then reset the width to 10 (very fat).
-        
+
         ::
-        
+
             sage: p = plot(cos, (-3,3))
             sage: p.axes_width()
             0.8
             sage: p.axes_width(10)
             sage: p.axes_width()
             10.0
-        
+
         Finally we plot the result, which is a graph with very fat axes.
-        
+
         ::
-        
+
             sage: p
         """
         if w is None:
@@ -728,18 +728,18 @@
     def tick_label_color(self, c=None):
         """
         Set the color of the axes tick labels.
-        
+
         INPUT:
-        
-        
+
+
         -  ``c`` - an RGB 3-tuple of numbers between 0 and 1
-        
-        
+
+
         If called with no input, return the current tick_label_color
         setting.
-        
+
         EXAMPLES::
-        
+
             sage: p = plot(cos, (-3,3))
             sage: p.tick_label_color()
             (0, 0, 0)
@@ -759,44 +759,44 @@
     def _repr_(self):
         r"""
         Show this graphics objects.
-        
+
         If the ``show_default`` function has been called with
         True (the default), then you'll see this graphics object displayed.
         Otherwise you'll see a text representation of it.
-        
+
         EXAMPLES: We create a plot and call ``_repr_`` on it,
         which causes it to be displayed as a plot::
-        
+
             sage: P = plot(cos, (-1,1))
             sage: P._repr_()
             ''
-        
+
         Just doing this also displays the plot::
-        
+
             sage: P
-        
+
         Note that printing P with the ``print`` statement does
         not display the plot::
-        
+
             sage: print P
             Graphics object consisting of 1 graphics primitive
-        
+
         Now we turn off showing plots by default::
-        
+
             sage: show_default(False)
-        
+
         Now we just get a string. To show P you would have to do
         ``show(P)``.
-        
+
         ::
-        
+
             sage: P._repr_()
             'Graphics object consisting of 1 graphics primitive'
             sage: P
             Graphics object consisting of 1 graphics primitive
-        
+
         Finally, we turn ``show_default`` back on::
-        
+
             sage: show_default(True)
         """
         if SHOW_DEFAULT:
@@ -808,39 +808,39 @@
     def __str__(self):
         r"""
         Return string representation of this plot.
-        
+
         EXAMPLES::
-        
+
             sage: S = circle((0,0), 2); S.__str__()
             'Graphics object consisting of 1 graphics primitive'
             sage: print S
             Graphics object consisting of 1 graphics primitive
-        
+
         .. warning::
 
            ``__str__`` is not called when printing lists of graphics
            objects, which can be confusing, since they will all pop
            up. One workaround is to call ``show_default``:
-        
+
         For example, below when we do ``print v`` two plots are
         displayed::
-        
+
             sage: v = [circle((0,0), 2), circle((2,3), 1)]
             sage: print v
             [, ]
-        
+
         However, if we call ``show_default`` then we see the
         text representations of the graphics::
-        
+
             sage: show_default(False)
             sage: print v
             [Graphics object consisting of 1 graphics primitive, Graphics object consisting of 1 graphics primitive]
             sage: v
             [Graphics object consisting of 1 graphics primitive,
              Graphics object consisting of 1 graphics primitive]
-        
+
         ::
-        
+
             sage: show_default(True)
         """
         pr, i = '', 0
@@ -855,9 +855,9 @@
     def __getitem__(self, i):
         """
         Returns the ith graphics primitive object:
-        
+
         EXAMPLE::
-        
+
             sage: G = circle((1,1),2) + circle((2,2),5); print G
             Graphics object consisting of 2 graphics primitives
             sage: G[1]
@@ -869,9 +869,9 @@
         """
         If G is of type Graphics, then len(G) gives the number of distinct
         graphics primitives making up that object.
-        
+
         EXAMPLES::
-        
+
             sage: G = circle((1,1),1) + circle((1,2),1) + circle((1,2),5); print G
             Graphics object consisting of 3 graphics primitives
             sage: len(G)
@@ -883,9 +883,9 @@
         """
         If G is of type Graphics, then del(G[i]) removes the ith distinct
         graphic primitive making up that object.
-        
+
         EXAMPLES::
-        
+
             sage: G = circle((1,1),1) + circle((1,2),1) + circle((1,2),5); print G
             Graphics object consisting of 3 graphics primitives
             sage: len(G)
@@ -902,19 +902,19 @@
         """
         You can replace a GraphicPrimitive (point, line, circle, etc...) in
         a Graphics object G with any other GraphicPrimitive
-        
+
         EXAMPLES::
-        
+
             sage: G = circle((1,1),1) + circle((1,2),1) + circle((1,2),5); print G
             Graphics object consisting of 3 graphics primitives
-        
+
         ::
-        
+
             sage: p = polygon([[1,3],[2,-2],[1,1],[1,3]]); print p
             Graphics object consisting of 1 graphics primitive
-        
+
         ::
-        
+
             sage: G[1] = p[0]
             sage: G    # show the plot
         """
@@ -926,21 +926,21 @@
     def __radd__(self, other):
         """
         Compute and return other + this graphics object.
-        
+
         This only works when other is a Python int equal to 0. In all other
         cases a TypeError is raised. The main reason for this function is
         to make summing a list of graphics objects easier.
-        
+
         EXAMPLES::
-        
+
             sage: S = circle((0,0), 2)
             sage: print int(0) + S
             Graphics object consisting of 1 graphics primitive
             sage: print S + int(0)
             Graphics object consisting of 1 graphics primitive
-        
+
         The following would fail were it not for this function::
-        
+
             sage: v = [circle((0,0), 2), circle((2,3), 1)]
             sage: print sum(v)
             Graphics object consisting of 2 graphics primitives
@@ -954,7 +954,7 @@
         If you have any Graphics object G1, you can always add any other
         amount of Graphics objects G2,G3,... to form a new Graphics object:
         G4 = G1 + G2 + G3.
-        
+
         The xmin, xmax, ymin, and ymax properties of the graphics objects
         are expanded to include all objects in both scenes. If the aspect
         ratio property of either or both objects are set, then the larger
@@ -966,7 +966,7 @@
         legend options are carried over.
 
         EXAMPLES::
-        
+
             sage: g1 = plot(abs(sqrt(x^3-1)), (x,1,5), frame=True)
             sage: g2 = plot(-abs(sqrt(x^3-1)), (x,1,5), color='red')
             sage: g1 + g2  # displays the plot
@@ -1003,7 +1003,7 @@
         else:
             g.set_aspect_ratio( max(self.aspect_ratio(), other.aspect_ratio()))
         return g
-  
+
     def add_primitive(self, primitive):
         """
         Adds a primitive to this graphics object.
@@ -1027,23 +1027,23 @@
         """
         Draw a 2D plot of this graphics object, which just returns this
         object since this is already a 2D graphics object.
-        
+
         EXAMPLES::
-        
+
             sage: S = circle((0,0), 2)
             sage: S.plot() is S
             True
         """
         return self
-        
+
     def plot3d(self, z=0, **kwds):
         """
         Returns an embedding of this 2D plot into the xy-plane of 3D space,
         as a 3D plot object. An optional parameter z can be given to
         specify the z-coordinate.
-        
+
         EXAMPLES::
-        
+
             sage: sum([plot(z*sin(x), 0, 10).plot3d(z) for z in range(6)]) # long time
         """
         from sage.plot.plot3d.base import Graphics3dGroup
@@ -1051,7 +1051,7 @@
         if z:
             g = g.translate(0,0,z)
         return g
-        
+
     @classmethod
     def _extract_kwds_for_show(cls, kwds, ignore=[]):
         """
@@ -1150,11 +1150,11 @@
           is determined by ``figsize`` and the picture fills the figure.
 
         - ``axes`` - (default: True)
-       
+
         - ``axes_labels`` - (default: None) list (or tuple) of two
           strings; the first is used as the label for the horizontal
           axis, and the second for the vertical axis.
-                            
+
         - ``fontsize`` - (default: current setting -- 10) positive
           integer; used for axes labels; if you make this very large,
           you may have to increase figsize to see all labels.
@@ -1265,106 +1265,106 @@
         - ``legend_*`` - all the options valid for :meth:`set_legend_options` prefixed with ``legend_``
 
         EXAMPLES::
-        
+
             sage: c = circle((1,1), 1, color='red')
             sage: c.show(xmin=-1, xmax=3, ymin=-1, ymax=3)
-        
+
         You could also just make the picture larger by changing ``figsize``::
 
             sage: c.show(figsize=8, xmin=-1, xmax=3, ymin=-1, ymax=3)
-        
+
         You can turn off the drawing of the axes::
-        
+
             sage: show(plot(sin,-4,4), axes=False)
-        
+
         You can also label the axes.  Putting something in dollar
         signs formats it as a mathematical expression::
-        
+
             sage: show(plot(sin,-4,4), axes_labels=('$x$','$y$'))
-        
+
         You can turn on the drawing of a frame around the plots::
-        
+
             sage: show(plot(sin,-4,4), frame=True)
-        
+
         You can make the background transparent::
 
             sage: plot(sin(x), (x, -4, 4), transparent=True)
 
         Add grid lines at the major ticks of the axes.
-        
+
         ::
-        
+
             sage: c = circle((0,0), 1)
             sage: c.show(gridlines=True)
             sage: c.show(gridlines="automatic")
             sage: c.show(gridlines="major")
-        
+
         Add grid lines at the major and minor ticks of the axes.
-        
+
         ::
-        
+
             sage: u,v = var('u v')
             sage: f = exp(-(u^2+v^2))
             sage: p = plot_vector_field(f.gradient(), (u,-2,2), (v,-2,2))
             sage: p.show(gridlines="minor")
-        
+
         Add only horizontal or vertical grid lines.
-        
+
         ::
-        
+
             sage: p = plot(sin,-10,20)
             sage: p.show(gridlines=[None, "automatic"])
             sage: p.show(gridlines=["minor", False])
-        
+
         Add grid lines at specific positions (using lists/tuples).
-        
+
         ::
-        
+
             sage: x, y = var('x, y')
             sage: p = implicit_plot((y^2-x^2)*(x-1)*(2*x-3)-4*(x^2+y^2-2*x)^2, \
             ...             (x,-2,2), (y,-2,2), plot_points=1000)
             sage: p.show(gridlines=[[1,0],[-1,0,1]])
-        
+
         Add grid lines at specific positions (using iterators).
-        
+
         ::
-        
+
             sage: def maple_leaf(t):
             ...     return (100/(100+(t-pi/2)^8))*(2-sin(7*t)-cos(30*t)/2)
             sage: p = polar_plot(maple_leaf, -pi/4, 3*pi/2, color="red",plot_points=1000) # long time
             sage: p.show(gridlines=( [-3,-2.75,..,3], xrange(-1,5,2) )) # long time
-        
+
         Add grid lines at specific positions (using functions).
-        
+
         ::
-        
+
             sage: y = x^5 + 4*x^4 - 10*x^3 - 40*x^2 + 9*x + 36
             sage: p = plot(y, -4.1, 1.1)
             sage: xlines = lambda a,b: [z for z,m in y.roots()]
             sage: p.show(gridlines=[xlines, [0]], frame=True, axes=False)
-        
+
         Change the style of all the grid lines.
-        
+
         ::
-        
+
             sage: b = bar_chart([-3,5,-6,11], color='red')
             sage: b.show(gridlines=([-1,-0.5,..,4],True),
             ...     gridlinesstyle=dict(color="blue", linestyle=":"))
-        
+
         Change the style of the horizontal or vertical grid lines
         separately.
-        
+
         ::
-        
+
             sage: p = polar_plot(2 + 2*cos(x), 0, 2*pi, color=hue(0.3))
             sage: p.show(gridlines=True,
             ...     hgridlinesstyle=dict(color="orange", linewidth=1.0),
             ...     vgridlinesstyle=dict(color="blue", linestyle=":"))
-        
+
         Change the style of each grid line individually.
-        
+
         ::
-        
+
             sage: x, y = var('x, y')
             sage: p = implicit_plot((y^2-x^2)*(x-1)*(2*x-3)-4*(x^2+y^2-2*x)^2,
             ...             (x,-2,2), (y,-2,2), plot_points=1000)
@@ -1380,19 +1380,19 @@
             ...    ]
             ...    ),
             ...    gridlinesstyle=dict(marker='x',color="black"))
-        
+
         Grid lines can be added to contour plots.
-        
+
         ::
-        
+
             sage: f = sin(x^2 + y^2)*cos(x)*sin(y)
             sage: c = contour_plot(f, (x, -4, 4), (y, -4, 4), plot_points=100)
             sage: c.show(gridlines=True, gridlinesstyle={'linestyle':':','linewidth':1, 'color':'red'})
-        
+
         Grid lines can be added to matrix plots.
-        
+
         ::
-        
+
             sage: M = MatrixSpace(QQ,10).random_element()
             sage: matrix_plot(M).show(gridlines=True)
 
@@ -1405,10 +1405,10 @@
         ``axes_pad`` to zero.  Compare the following two examples
 
         ::
-        
+
             sage: plot(sin(x), (x, -pi, pi),thickness=2)+point((pi, -1), pointsize=15)
             sage: plot(sin(x), (x, -pi, pi),thickness=2,axes_pad=0)+point((pi, -1), pointsize=15)
-        
+
         Via matplotlib, Sage allows setting of custom ticks.  See above
         for more details.
 
@@ -1551,7 +1551,7 @@
         """
         Return a dictionary whose keys give the xmin, xmax, ymin, and ymax
         data for this graphic.
-        
+
         .. warning::
 
            The returned dictionary is mutable, but changing it does
@@ -1599,7 +1599,104 @@
             ymin -= 1
             ymax += 1
         return {'xmin':xmin, 'xmax':xmax, 'ymin':ymin, 'ymax':ymax}
-        
+
+    def _matplotlib_tick_formatter(self, subplot, locator_options={},
+                            tick_formatter=(None, None), ticks=(None, None),
+                            xmax=None, xmin=None, ymax=None, ymin=None):
+        r"""
+        Take a matplotlib subplot instance representing the graphic and set
+        the ticks formatting. This function is only for internal use.
+
+        INPUT:
+        - ``subplot`` -- the subplot instance.
+
+        EXAMPLES::
+
+            sage: from matplotlib.figure import Figure
+            sage: p = plot(x); d = p.get_minmax_data()
+            sage: subplot = Figure().add_subplot(111)
+            sage: p._objects[0]._render_on_subplot(subplot)
+            sage: p._matplotlib_tick_formatter(subplot, **d)
+            (<matplotlib.axes.AxesSubplot object at ...>,
+            <matplotlib.ticker.MaxNLocator instance at ...>,
+            <matplotlib.ticker.MaxNLocator instance at ...>,
+            <matplotlib.ticker.OldScalarFormatter instance at ...>,
+            <matplotlib.ticker.OldScalarFormatter instance at ...>)
+        """
+        # This function is created to refactor some code that is repeated
+        # in the matplotlib function
+        from matplotlib.ticker import (FixedLocator, Locator, MaxNLocator,
+                MultipleLocator, NullLocator, OldScalarFormatter)
+
+        x_locator, y_locator = ticks
+        #---------------------- Location of x-ticks ---------------------#
+        if x_locator is None:
+            x_locator = MaxNLocator(**locator_options)
+        elif isinstance(x_locator,Locator):
+            pass
+        elif x_locator == []:
+            x_locator = NullLocator()
+        elif isinstance(x_locator,list):
+            x_locator = FixedLocator(x_locator)
+        else: # x_locator is a number which can be made a float
+            from sage.functions.other import ceil, floor
+            if floor(xmax/x_locator)-ceil(xmin/x_locator)>1:
+                x_locator=MultipleLocator(float(x_locator))
+            else: # not enough room for two major ticks
+                raise ValueError('Expand the range of the independent '
+                'variable to allow two multiples of your tick locator '
+                '(option `ticks`).')
+
+        #---------------------- Location of y-ticks ---------------------#
+        if y_locator is None:
+            y_locator = MaxNLocator(**locator_options)
+        elif isinstance(y_locator,Locator):
+            pass
+        elif y_locator == []:
+            y_locator = NullLocator()
+        elif isinstance(y_locator,list):
+            y_locator = FixedLocator(y_locator)
+        else: # y_locator is a number which can be made a float
+            from sage.functions.other import ceil, floor
+            if floor(ymax/y_locator)-ceil(ymin/y_locator)>1:
+                y_locator=MultipleLocator(float(y_locator))
+            else: # not enough room for two major ticks
+                raise ValueError('Expand the range of the dependent '
+                'variable to allow two multiples of your tick locator '
+                '(option `ticks`).')
+
+        x_formatter, y_formatter = tick_formatter
+        from matplotlib.ticker import FuncFormatter
+        from sage.misc.latex import latex
+        from sage.symbolic.ring import SR
+        #---------------------- Formatting x-ticks ----------------------#
+        if x_formatter is None:
+            x_formatter = OldScalarFormatter()
+        elif x_formatter in SR:
+            from misc import _multiple_of_constant
+            x_const = x_formatter
+            x_formatter = FuncFormatter(lambda n,pos:
+                                        _multiple_of_constant(n,pos,x_const))
+        elif x_formatter == "latex":
+            x_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))
+        #---------------------- Formatting y-ticks ----------------------#
+        if y_formatter is None:
+            y_formatter = OldScalarFormatter()
+        elif y_formatter in SR:
+            from misc import _multiple_of_constant
+            y_const = y_formatter
+            y_formatter = FuncFormatter(lambda n,pos:
+                                        _multiple_of_constant(n,pos,y_const))
+        elif y_formatter == "latex":
+            y_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))
+
+        subplot.xaxis.set_major_locator(x_locator)
+        subplot.yaxis.set_major_locator(y_locator)
+        subplot.xaxis.set_major_formatter(x_formatter)
+        subplot.yaxis.set_major_formatter(y_formatter)
+
+        return (subplot, x_locator, y_locator, x_formatter, y_formatter)
+
     def matplotlib(self, filename=None,
                    xmin=None, xmax=None, ymin=None, ymax=None,
                    figsize=None, figure=None, sub=None,
@@ -1615,7 +1712,7 @@
         Return a matplotlib figure object representing the graphic
 
         EXAMPLES::
-        
+
             sage: c = circle((1,1),1)
             sage: print c.matplotlib()
             Figure(640x480)
@@ -1654,14 +1751,14 @@
                 tick_formatter = (tick_formatter, "latex")
             else:
                 tick_formatter = (tick_formatter, None)
-            
+
         self.set_axes_range(xmin, xmax, ymin, ymax)
         d = self.get_axes_range()
         xmin = d['xmin']
         xmax = d['xmax']
         ymin = d['ymin']
         ymax = d['ymax']
-        
+
         x_pad=(xmax-xmin)*float(axes_pad)
         y_pad=(ymax-ymin)*float(axes_pad)
 
@@ -1669,7 +1766,7 @@
         xmax+=x_pad
         ymin-=y_pad
         ymax+=y_pad
-                
+
         global do_verify
         do_verify = verify
 
@@ -1687,7 +1784,7 @@
 
         if figure is None:
             figure=Figure(figsize=figsize)
-        
+
         #the incoming subplot instance
         subplot = sub
         if not subplot:
@@ -1703,11 +1800,11 @@
             g._render_on_subplot(subplot)
             if hasattr(g, '_bbox_extra_artists'):
                 self._bbox_extra_artists.extend(g._bbox_extra_artists)
-        
+
         #add the legend if requested
         if show_legend is None:
             show_legend = self._show_legend
-        
+
         if show_legend:
             from matplotlib.font_manager import FontProperties
             lopts = dict()
@@ -1723,8 +1820,8 @@
                 # color
                 lframe = leg.get_frame()
                 lframe.set_facecolor(color)
-        
-            
+
+
         subplot.set_xlim([xmin, xmax])
         subplot.set_ylim([ymin,ymax])
 
@@ -1737,69 +1834,19 @@
         for spine in subplot.spines.values():
             spine.set_color(self._axes_color)
             spine.set_linewidth(self._axes_width)
-        
+
 
         if frame:
             # For now, set the formatter to the old one, since that is
             # sort of what we are used to.  We should eventually look at
             # the default one to see if we like it better.
 
-            from matplotlib.ticker import OldScalarFormatter, MaxNLocator, MultipleLocator, FixedLocator, NullLocator, Locator
-            x_locator, y_locator = ticks
-            if x_locator is None:
-                x_locator = MaxNLocator(**locator_options)
-            elif isinstance(x_locator,Locator):
-                pass
-            elif x_locator == []:
-                x_locator = NullLocator()
-            elif isinstance(x_locator,list):
-                x_locator = FixedLocator(x_locator)
-            else: # x_locator is a number which can be made a float
-                from sage.functions.other import ceil, floor
-                if floor(xmax/x_locator)-ceil(xmin/x_locator)>1:
-                    x_locator=MultipleLocator(float(x_locator))
-                else: # not enough room for two major ticks
-                    raise ValueError('Expand the range of the independent variable to allow two multiples of your tick locator (option `ticks`).')
-            if y_locator is None:
-                y_locator = MaxNLocator(**locator_options)
-            elif isinstance(y_locator,Locator):
-                pass
-            elif y_locator == []:
-                y_locator = NullLocator()
-            elif isinstance(y_locator,list):
-                y_locator = FixedLocator(y_locator)
-            else: # y_locator is a number which can be made a float
-                from sage.functions.other import ceil, floor
-                if floor(ymax/y_locator)-ceil(ymin/y_locator)>1:
-                    y_locator=MultipleLocator(float(y_locator))
-                else: # not enough room for two major ticks
-                    raise ValueError('Expand the range of the dependent variable to allow two multiples of your tick locator (option `ticks`).')
-
-            x_formatter, y_formatter = tick_formatter
-            from matplotlib.ticker import FuncFormatter
-            from sage.misc.latex import latex
-            if x_formatter is None:
-                x_formatter = OldScalarFormatter()
-            elif x_formatter in SR:
-                from misc import _multiple_of_constant
-                x_const = x_formatter
-                x_formatter = FuncFormatter(lambda n,pos: _multiple_of_constant(n,pos,x_const))
-            elif x_formatter == "latex":
-                x_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))
-            if y_formatter is None:
-                y_formatter = OldScalarFormatter()
-            elif y_formatter in SR:
-                from misc import _multiple_of_constant
-                y_const = y_formatter
-                y_formatter = FuncFormatter(lambda n,pos: _multiple_of_constant(n,pos,y_const))
-            elif y_formatter == "latex":
-                y_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))
-
-            subplot.xaxis.set_major_locator(x_locator)
-            subplot.yaxis.set_major_locator(y_locator)
-            subplot.xaxis.set_major_formatter(x_formatter)
-            subplot.yaxis.set_major_formatter(y_formatter)
-            
+            subplot, x_locator, y_locator, x_formatter, y_formatter = \
+                    self._matplotlib_tick_formatter(subplot,
+                            locator_options=locator_options,
+                            tick_formatter=tick_formatter, ticks=ticks,
+                            xmax=xmax, xmin=xmin, ymax=ymax, ymin=ymin)
+
             subplot.set_frame_on(True)
             if axes:
                 if ymin<=0 and ymax>=0:
@@ -1808,7 +1855,7 @@
                 if xmin<=0 and xmax>=0:
                     subplot.axvline(color=self._axes_color,
                                     linewidth=self._axes_width)
-            
+
         elif axes:
             ymiddle=False
             xmiddle=False
@@ -1851,67 +1898,16 @@
                 subplot.spines['top'].set_visible(False)
                 xmiddle=True
                 xaxis='bottom'
-            
+
             # For now, set the formatter to the old one, since that is
             # sort of what we are used to.  We should eventually look at
             # the default one to see if we like it better.
-            
-            from matplotlib.ticker import OldScalarFormatter, MaxNLocator, MultipleLocator, FixedLocator, NullLocator, Locator
-            x_locator, y_locator = ticks
-            if x_locator is None:
-                x_locator = MaxNLocator(**locator_options)
-            elif isinstance(x_locator,Locator):
-                pass
-            elif x_locator == []:
-                x_locator = NullLocator()
-            elif isinstance(x_locator,list):
-                x_locator = FixedLocator(x_locator)
-            else: # x_locator is a number which can be made a float
-                from sage.functions.other import ceil, floor
-                if floor(xmax/x_locator)-ceil(xmin/x_locator)>1:
-                    x_locator=MultipleLocator(float(x_locator))
-                else: # not enough room for two major ticks
-                    raise ValueError('Expand the range of the independent variable to allow two multiples of your tick locator (option `ticks`).')
-            if y_locator is None:
-                y_locator = MaxNLocator(**locator_options)
-            elif isinstance(y_locator,Locator):
-                pass
-            elif y_locator == []:
-                y_locator = NullLocator()
-            elif isinstance(y_locator,list):
-                y_locator = FixedLocator(y_locator)
-            else: # y_locator is a number which can be made a float
-                from sage.functions.other import ceil, floor
-                if floor(ymax/y_locator)-ceil(ymin/y_locator)>1:
-                    y_locator=MultipleLocator(float(y_locator))
-                else: # not enough room for two major ticks
-                    raise ValueError('Expand the range of the dependent variable to allow two multiples of your tick locator (option `ticks`).')
-
-            x_formatter, y_formatter = tick_formatter
-            from matplotlib.ticker import FuncFormatter
-            from sage.misc.latex import latex
-            from sage.symbolic.ring import SR
-            if x_formatter is None:
-                x_formatter = OldScalarFormatter()
-            elif x_formatter in SR:
-                from misc import _multiple_of_constant
-                x_const = x_formatter
-                x_formatter = FuncFormatter(lambda n,pos: _multiple_of_constant(n,pos,x_const))
-            elif x_formatter == "latex":
-                x_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))
-            if y_formatter is None:
-                y_formatter = OldScalarFormatter()
-            elif y_formatter in SR:
-                from misc import _multiple_of_constant
-                y_const = y_formatter
-                y_formatter = FuncFormatter(lambda n,pos: _multiple_of_constant(n,pos,y_const))
-            elif y_formatter == "latex":
-                y_formatter = FuncFormatter(lambda n,pos: '$%s$'%latex(n))
-
-            subplot.xaxis.set_major_locator(x_locator)
-            subplot.yaxis.set_major_locator(y_locator)
-            subplot.xaxis.set_major_formatter(x_formatter)
-            subplot.yaxis.set_major_formatter(y_formatter)
+
+            subplot, x_locator, y_locator, x_formatter, y_formatter = \
+                    self._matplotlib_tick_formatter(subplot,
+                            locator_options=locator_options,
+                            tick_formatter=tick_formatter, ticks=ticks,
+                            xmax=xmax, xmin=xmin, ymax=ymax, ymin=ymin)
 
             # Make ticklines go on both sides of the axes
             #             if xmiddle:
@@ -1921,7 +1917,7 @@
             #                 for t in subplot.xaxis.get_minorticklines():
             #                     t.set_marker("|")
             #                     t.set_markersize(4)
-            
+
             #             if ymiddle:
             #                 for t in subplot.yaxis.get_majorticklines():
             #                     t.set_marker("|")
@@ -1929,13 +1925,15 @@
             #                 for t in subplot.yaxis.get_minorticklines():
             #                     t.set_marker("|")
             #                     t.set_markersize(4)
-            
+
             # Make the zero tick labels disappear if the axes cross
             # inside the picture
             if xmiddle and ymiddle:
                 from sage.plot.plot import SelectiveFormatter
-                subplot.yaxis.set_major_formatter(SelectiveFormatter(subplot.yaxis.get_major_formatter(),skip_values=[0]))
-                subplot.xaxis.set_major_formatter(SelectiveFormatter(subplot.xaxis.get_major_formatter(),skip_values=[0]))
+                subplot.yaxis.set_major_formatter(SelectiveFormatter(
+                    subplot.yaxis.get_major_formatter(), skip_values=[0]))
+                subplot.xaxis.set_major_formatter(SelectiveFormatter(
+                    subplot.xaxis.get_major_formatter(), skip_values=[0]))
 
         else:
             for spine in subplot.spines.values():
@@ -1972,8 +1970,8 @@
                 subplot.yaxis.get_minorticklines()
             for tickline in ticklines:
                 tickline.set_color(self._axes_color)
-                
-            
+
+
         if gridlines is not None:
             if isinstance(gridlines, (list, tuple)):
                 vgridlines,hgridlines=gridlines
@@ -1997,7 +1995,7 @@
                 hgridstyle['which']='both'
             if vgridlines=='minor':
                 vgridstyle['which']='both'
-                
+
             if hasattr(hgridlines, '__iter__'):
                 hlines=iter(hgridlines)
                 hgridstyle.pop("minor",None)
@@ -2038,7 +2036,7 @@
             label_options['size']=self._fontsize
             subplot.set_xlabel(self._axes_labels[0], **label_options)
             subplot.set_ylabel(self._axes_labels[1], **label_options)
-                
+
 
             if axes is True and frame is False:
                 # We set the label positions according to where we are
@@ -2072,23 +2070,27 @@
                 xlabel.set_horizontalalignment(xaxis_horiz)
                 xlabel.set_verticalalignment(xaxis_vert)
                 trans=subplot.spines[xaxis].get_transform()
-                labeltrans=offset_copy(trans, figure, x=xaxis_labeloffset, y=0, units='points')
-                subplot.xaxis.set_label_coords(x=xaxis_labelx,y=xaxis_labely,transform=labeltrans)
+                labeltrans=offset_copy(trans, figure, x=xaxis_labeloffset,
+                        y=0, units='points')
+                subplot.xaxis.set_label_coords(x=xaxis_labelx,
+                        y=xaxis_labely,transform=labeltrans)
 
                 ylabel=subplot.yaxis.get_label()
                 ylabel.set_horizontalalignment('center')
                 ylabel.set_verticalalignment(yaxis_vert)
                 ylabel.set_rotation('horizontal')
                 trans=subplot.spines[yaxis].get_transform()
-                labeltrans=offset_copy(trans, figure, x=0, y=yaxis_labeloffset, units='points')
-                subplot.yaxis.set_label_coords(x=yaxis_labelx,y=yaxis_labely,transform=labeltrans)
+                labeltrans=offset_copy(trans, figure, x=0,
+                        y=yaxis_labeloffset, units='points')
+                subplot.yaxis.set_label_coords(x=yaxis_labelx,
+                        y=yaxis_labely,transform=labeltrans)
 
         # This option makes the xlim and ylim limits not take effect
         # todo: figure out which limits were specified, and let the
         # free limits autoscale
         #subplot.autoscale_view(tight=True)
         return figure
-        
+
     # ALLOWED_EXTENSIONS is the list of recognized formats.
     # filename argument is written explicitly so that it can be used as a
     # positional one, which is a very likely usage for this function.
@@ -2100,35 +2102,35 @@
     def save(self, filename=None, **kwds):
         r"""
         Save the graphics to an image file.
-       
+
         INPUT:
-        
+
         - ``filename`` -- a string (default: autogenerated), the filename and
           the image format given by the extension, which can be one of the
           following:
-         
+
             * ``.eps``,
-           
+
             * ``.pdf``,
-           
+
             * ``.png``,
-           
+
             * ``.ps``,
-           
+
             * ``.sobj`` (for a Sage object you can load later),
-            
+
             * ``.svg``,
-           
+
             * empty extension will be treated as ``.sobj``.
-           
+
         All other keyword arguments will be passed to the plotter.
-        
+
         OUTPUT:
-        
+
         - none.
 
         EXAMPLES::
-        
+
             sage: c = circle((1,1), 1, color='red')
             sage: filename = os.path.join(SAGE_TMP, 'test.png')
             sage: c.save(filename, xmin=-1, xmax=3, ymin=-1, ymax=3)
@@ -2144,17 +2146,17 @@
 
             sage: c.save(filename, figsize=[8,4], fig_tight=False,
             ...       xmin=-1, xmax=3, ymin=-1, ymax=3)
-        
+
         You can also pass extra options to the plot command instead of this
         method, e.g. ::
-        
+
             sage: plot(x^2 - 5, (x, 0, 5), ymin=0).save(
             ...       sage.misc.misc.tmp_filename() + '.png')
-            
+
         will save the same plot as the one shown by this command::
-        
+
             sage: plot(x^2 - 5, (x, 0, 5), ymin=0)
-            
+
         (This test verifies that :trac:`8632` is fixed.)
 
         TESTS:
@@ -2183,13 +2185,13 @@
         dpi = options.pop('dpi')
         transparent = options.pop('transparent')
         fig_tight = options.pop('fig_tight')
-        
+
         if filename is None:
             filename = options.pop('filename')
         if filename is None:
             filename = sage.misc.misc.graphics_filename()
         ext = os.path.splitext(filename)[1].lower()
-        
+
         if ext not in ALLOWED_EXTENSIONS:
             raise ValueError("allowed file extensions for images are '"
                              + "', '".join(ALLOWED_EXTENSIONS) + "'!")
@@ -2197,7 +2199,8 @@
             SageObject.save(self, filename)
         else:
             figure = self.matplotlib(**options)
-            # You can output in PNG, PS, EPS, PDF, or SVG format, depending on the file extension.
+            # You can output in PNG, PS, EPS, PDF, or SVG format, depending
+            # on the file extension.
             # matplotlib looks at the file extension to see what the renderer should be.
             # The default is FigureCanvasAgg for PNG's because this is by far the most
             # common type of files rendered, like in the notebook, for example.
@@ -2206,7 +2209,7 @@
             figure.set_canvas(FigureCanvasAgg(figure))
             # this messes up the aspect ratio!
             #figure.canvas.mpl_connect('draw_event', pad_for_tick_labels)
-            
+
             # tight_layout adjusts the *subplot* parameters so ticks aren't cut off, etc.
             figure.tight_layout()
 
@@ -2358,7 +2361,7 @@
             6
         """
         return self._cols
-    
+
     def __getitem__(self, i):
         """
         Return the ``i``th element of the list of graphics
@@ -2416,7 +2419,7 @@
         """
         i = int(i)
         self._glist[i] = g
-        
+
     def _set_figsize_(self, ls):
         """
         Set the figsize of all plots in the array.
@@ -2547,7 +2550,7 @@
              axes = None, **args):
         r"""
         Show this graphics array using the default viewer.
-        
+
         OPTIONAL INPUT:
 
         -  ``filename`` - (default: None) string
diff --git a/sage/plot/hyperbolic_arc.py b/sage/plot/hyperbolic_arc.py
--- a/sage/plot/hyperbolic_arc.py
+++ b/sage/plot/hyperbolic_arc.py
@@ -39,11 +39,11 @@
     Note that constructions should use ``hyperbolic_arc``::
 
          sage: from sage.plot.hyperbolic_arc import HyperbolicArc
-        
+
          sage: print HyperbolicArc(0, 1/2+I*sqrt(3)/2, {})
          Hyperbolic arc (0.000000000000000, 0.500000000000000 + 0.866025403784439*I)
     """
-    
+
     def __init__(self, A, B, options):
         A, B = (CC(A), CC(B))
         self.path = []
@@ -56,7 +56,7 @@
         String representation of HyperbolicArc.
         """
         return "Hyperbolic arc (%s, %s)" % (self.A, self.B)
-    
+
     def _hyperbolic_arc(self, z0, z3, first=False):
         """
         Function to construct Bezier path as an approximation to
@@ -91,7 +91,7 @@
             self.path.append([(z1.real(), z1.imag()),
                               (z2.real(), z2.imag()),
                               (z3.real(), z3.imag())]);
-     
+
 @rename_keyword(color='rgbcolor')
 @options(alpha=1, fill=False, thickness=1, rgbcolor="blue", zorder=2, linestyle='solid')
 def hyperbolic_arc(a, b, **options):
@@ -105,9 +105,9 @@
       connected bye the arc
 
     OPTIONS:
-    
+
     - ``alpha`` - default: 1
-       
+
     - ``thickness`` - default: 1
 
     - ``rgbcolor`` - default: 'blue'
@@ -117,15 +117,15 @@
     Examples:
 
     Show a hyperbolic arc from 0 to 1::
-    
+
          sage: hyperbolic_arc(0, 1)
 
     Show a hyperbolic arc from 1/2 to `i` with a red thick line::
-    
+
          sage: hyperbolic_arc(1/2, I, color='red', thickness=2)
 
     Show a hyperbolic arc form `i` to `2 i` with dashed line::
-    
+
          sage: hyperbolic_arc(I, 2*I, linestyle='dashed')
     """
     from sage.plot.all import Graphics
diff --git a/sage/plot/hyperbolic_triangle.py b/sage/plot/hyperbolic_triangle.py
--- a/sage/plot/hyperbolic_triangle.py
+++ b/sage/plot/hyperbolic_triangle.py
@@ -33,7 +33,7 @@
 
     - ``a,b,c`` - coordinates of the hyperbolic triangle in the upper
       complex plane
-    
+
     - ``options`` - dict of valid plot options to pass to constructor
 
     EXAMPLES:
@@ -49,7 +49,7 @@
         Initialize HyperbolicTriangle:
 
         Examples::
-        
+
             sage: from sage.plot.hyperbolic_triangle import HyperbolicTriangle
             sage: print HyperbolicTriangle(0, 1/2, I, {})
             Hyperbolic triangle (0.000000000000000, 0.500000000000000, 1.00000000000000*I)
@@ -67,7 +67,7 @@
         String representation of HyperbolicTriangle.
         """
         return "Hyperbolic triangle (%s, %s, %s)" % (self.A, self.B, self.C)
-    
+
     def _hyperbolic_arc(self, z0, z3, first=False):
         """
         Function to construct Bezier path as an approximation to
@@ -102,7 +102,7 @@
             self.path.append([(z1.real(), z1.imag()),
                               (z2.real(), z2.imag()),
                               (z3.real(), z3.imag())]);
-     
+
 @rename_keyword(color='rgbcolor')
 @options(alpha=1, fill=False, thickness=1, rgbcolor="blue", zorder=2, linestyle='solid')
 
@@ -116,9 +116,9 @@
     - ``a, b, c`` - complex numbers in the upper half complex plane
 
     OPTIONS:
-    
+
     - ``alpha`` - default: 1
-       
+
     - ``fill`` - default: False
 
     - ``thickness`` - default: 1
@@ -131,11 +131,11 @@
 
     Show a hyperbolic triangle with coordinates 0, `1/2+i\sqrt{3}/2` and
     `-1/2+i\sqrt{3}/2`::
-    
+
          sage: hyperbolic_triangle(0, -1/2+I*sqrt(3)/2, 1/2+I*sqrt(3)/2)
 
     A hyperbolic triangle with coordinates 0, 1 and 2+i::
-    
+
          sage: hyperbolic_triangle(0, 1, 2+i, fill=true, rgbcolor='red')
     """
     from sage.plot.all import Graphics
diff --git a/sage/plot/java3d.py b/sage/plot/java3d.py
--- a/sage/plot/java3d.py
+++ b/sage/plot/java3d.py
@@ -13,11 +13,11 @@
 
 class Java3DApplet(Applet):
     def __init__(self, width=400, height=400, inline=None):
-        Applet.__init__(self, 
+        Applet.__init__(self,
                         code = "org.jdesktop.applet.util.JNLPAppletLauncher",
                         width = width,
                         height = height,
                         archive = ["lib/sage3d.jar"] + ["sun-libs/" + lib for lib in sun_libs],
                         codebase = "3d",
                         params = sun_params)
-    
+
diff --git a/sage/plot/line.py b/sage/plot/line.py
--- a/sage/plot/line.py
+++ b/sage/plot/line.py
@@ -5,7 +5,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -53,7 +53,7 @@
     def _allowed_options(self):
         """
         Displayed the list of allowed line options.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.line import Line
@@ -72,7 +72,7 @@
              ('thickness', 'How thick the line is.'),
              ('zorder', 'The layer level in which to draw')]
         """
-        return {'alpha':'How transparent the line is.', 
+        return {'alpha':'How transparent the line is.',
                 'legend_label':'The label for this item in the legend.',
                'thickness':'How thick the line is.',
                 'rgbcolor':'The color as an RGB tuple.',
@@ -85,10 +85,10 @@
                 'markerfacecolor':'the color of the marker face',
                 'zorder':'The layer level in which to draw'
                 }
-                
+
     def _plot3d_options(self, options=None):
         """
-        Translate 2D plot options into 3D plot options. 
+        Translate 2D plot options into 3D plot options.
 
         EXAMPLES::
 
@@ -134,11 +134,11 @@
         options = self._plot3d_options()
         options.update(kwds)
         return line3d([(x, y, z) for x, y in zip(self.xdata, self.ydata)], **options)
-        
+
     def _repr_(self):
         """
         String representation of a line primitive.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.line import Line
@@ -158,7 +158,7 @@
         OUTPUT:
 
         A 2-tuple of floats.
-        
+
         EXAMPLES::
 
             sage: L = line([(1,2), (3,-4), (2, 5), (1,2)])
@@ -225,7 +225,7 @@
 
     def _render_on_subplot(self, subplot):
         """
-        Render this line on a matplotlib subplot. 
+        Render this line on a matplotlib subplot.
 
         INPUT:
 
@@ -243,19 +243,19 @@
         del options['thickness']
         del options['rgbcolor']
         del options['legend_label']
-        if 'linestyle' in options: 
+        if 'linestyle' in options:
             del options['linestyle']
         p = lines.Line2D(self.xdata, self.ydata, **options)
         options = self.options()
         a = float(options['alpha'])
         p.set_alpha(a)
         p.set_linewidth(float(options['thickness']))
-        p.set_color(to_mpl_color(options['rgbcolor']))  
+        p.set_color(to_mpl_color(options['rgbcolor']))
         p.set_label(options['legend_label'])
-        # we don't pass linestyle in directly since the drawstyles aren't 
+        # we don't pass linestyle in directly since the drawstyles aren't
         # pulled off automatically.  This (I think) is a bug in matplotlib 1.0.1
-        if 'linestyle' in options: 
-            p.set_linestyle(options['linestyle']) 
+        if 'linestyle' in options:
+            p.set_linestyle(options['linestyle'])
         subplot.add_line(p)
 
 def line(points, **kwds):
@@ -280,16 +280,16 @@
         from sage.plot.plot3d.shapes2 import line3d
         return line3d(points, **kwds)
 
-    
+
 @rename_keyword(color='rgbcolor')
 @options(alpha=1, rgbcolor=(0,0,1), thickness=1, legend_label=None, aspect_ratio ='automatic')
 def line2d(points, **options):
     r"""
     Create the line through the given list of points.
 
-    Type \code{line2d.options} for a dictionary of the default options for 
+    Type \code{line2d.options} for a dictionary of the default options for
     lines.  You can change this to change the defaults for all future
-    lines.  Use \code{line2d.reset()} to reset to the default options. 
+    lines.  Use \code{line2d.reset()} to reset to the default options.
 
     INPUT:
 
@@ -321,7 +321,7 @@
          horizontal lines)
        - ``"steps-post"`` (step function; horizontal line is to the
          right of point)
-        
+
     - ``marker``  - The style of the markers, which is one of
        - ``"None"`` or ``" "`` or ``""`` (nothing) -- default
        - ``","`` (pixel), ``"."`` (point)
@@ -346,7 +346,7 @@
     EXAMPLES:
 
     A blue conchoid of Nicomedes::
- 
+
         sage: L = [[1+5*cos(pi/2+pi*i/100), tan(pi/2+pi*i/100)*(1+5*cos(pi/2+pi*i/100))] for i in range(1,100)]
         sage: line(L, rgbcolor=(1/4,1/8,3/4))
 
@@ -354,61 +354,61 @@
 
         sage: i = CC.0
         sage: line([1+i, 2+3*i])
- 
+
     A blue hypotrochoid (3 leaves)::
 
         sage: n = 4; h = 3; b = 2
         sage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]
         sage: line(L, rgbcolor=(1/4,1/4,3/4))
- 
+
     A blue hypotrochoid (4 leaves)::
- 
+
         sage: n = 6; h = 5; b = 2
         sage: L = [[n*cos(pi*i/100)+h*cos((n/b)*pi*i/100),n*sin(pi*i/100)-h*sin((n/b)*pi*i/100)] for i in range(200)]
         sage: line(L, rgbcolor=(1/4,1/4,3/4))
- 
+
     A red limacon of Pascal::
- 
+
         sage: L = [[sin(pi*i/100)+sin(pi*i/50),-(1+cos(pi*i/100)+cos(pi*i/50))] for i in range(-100,101)]
         sage: line(L, rgbcolor=(1,1/4,1/2))
- 
+
     A light green trisectrix of Maclaurin::
- 
+
         sage: L = [[2*(1-4*cos(-pi/2+pi*i/100)^2),10*tan(-pi/2+pi*i/100)*(1-4*cos(-pi/2+pi*i/100)^2)] for i in range(1,100)]
         sage: line(L, rgbcolor=(1/4,1,1/8))
- 
+
     A green lemniscate of Bernoulli::
 
         sage: cosines = [cos(-pi/2+pi*i/100) for i in range(201)]
         sage: v = [(1/c, tan(-pi/2+pi*i/100)) for i,c in enumerate(cosines) if c != 0]
         sage: L = [(a/(a^2+b^2), b/(a^2+b^2)) for a,b in v]
         sage: line(L, rgbcolor=(1/4,3/4,1/8))
- 
+
     A red plot of the Jacobi elliptic function `\text{sn}(x,2)`, `-3 < x < 3`::
- 
-        sage: L = [(i/100.0, jacobi('sn', i/100.0 ,2.0)) for i in range(-300,300,30)]    
+
+        sage: L = [(i/100.0, jacobi('sn', i/100.0 ,2.0)) for i in range(-300,300,30)]
         sage: line(L, rgbcolor=(3/4,1/4,1/8))
-        
+
     A red plot of `J`-Bessel function `J_2(x)`, `0 < x < 10`::
 
         sage: L = [(i/10.0, bessel_J(2,i/10.0)) for i in range(100)]
-        sage: line(L, rgbcolor=(3/4,1/4,5/8))    
-        
- 
+        sage: line(L, rgbcolor=(3/4,1/4,5/8))
+
+
     A purple plot of the Riemann zeta function `\zeta(1/2 + it)`, `0 < t < 30`::
 
         sage: i = CDF.gen()
         sage: v = [zeta(0.5 + n/10 * i) for n in range(300)]
         sage: L = [(z.real(), z.imag()) for z in v]
         sage: line(L, rgbcolor=(3/4,1/2,5/8))
- 
+
     A purple plot of the Hasse-Weil `L`-function `L(E, 1 + it)`, `-1 < t < 10`::
 
         sage: E = EllipticCurve('37a')
         sage: vals = E.lseries().values_along_line(1-I, 1+10*I, 100) # critical line
         sage: L = [(z[1].real(), z[1].imag()) for z in vals]
         sage: line(L, rgbcolor=(3/4,1/2,5/8))
- 
+
     A red, blue, and green "cool cat"::
 
         sage: G = plot(-cos(x), -2, 2, thickness=5, rgbcolor=(0.5,1,0.5))
@@ -426,7 +426,7 @@
         sage: line([(0,0),(1,1)], legend_label='line')
 
     Extra options will get passed on to show(), as long as they are valid::
-    
+
         sage: line([(0,1), (3,4)], figsize=[10, 2])
         sage: line([(0,1), (3,4)]).show(figsize=[10, 2]) # These are equivalent
     """
diff --git a/sage/plot/matrix_plot.py b/sage/plot/matrix_plot.py
--- a/sage/plot/matrix_plot.py
+++ b/sage/plot/matrix_plot.py
@@ -5,7 +5,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -24,12 +24,12 @@
 
 class MatrixPlot(GraphicPrimitive):
     """
-    Primitive class for the matrix plot graphics type.  See 
+    Primitive class for the matrix plot graphics type.  See
     ``matrix_plot?`` for help actually doing matrix plots.
 
     INPUT:
 
-    - ``xy_data_array`` - list of lists giving matrix values corresponding to 
+    - ``xy_data_array`` - list of lists giving matrix values corresponding to
       the grid
 
     - ``xrange`` - tuple of 2 floats indicating range for horizontal direction
@@ -69,7 +69,7 @@
     def __init__(self, xy_data_array, xrange, yrange, options):
         """
         Initializes base class MatrixPlot.
-        
+
         EXAMPLES::
 
             sage: M = matrix_plot([[mod(i,5)^j for i in range(5)] for j in range(1,6)], cmap='jet')
@@ -89,12 +89,12 @@
         else:
             self.xy_array_row = len(xy_data_array)
             self.xy_array_col = len(xy_data_array[0])
-        GraphicPrimitive.__init__(self, options)        
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-                
+
         EXAMPLES::
 
             sage: m = matrix_plot(matrix([[1,3,5,1],[2,4,5,6],[1,3,5,7]]))[0]
@@ -109,7 +109,7 @@
             # flip y-axis so that the picture looks correct.
             limits['ymin'],limits['ymax']=limits['ymax'],limits['ymin']
 
-        # center the matrix so that, for example, the square representing the 
+        # center the matrix so that, for example, the square representing the
         # (0,0) entry is centered on the origin.
         for k,v in limits.iteritems():
             limits[k]-=0.5
@@ -125,8 +125,8 @@
             sage: isinstance(M[0]._allowed_options(),dict)
             True
         """
-        return {'cmap':"""the name of a predefined colormap, 
-                        a list of colors, or an instance of a 
+        return {'cmap':"""the name of a predefined colormap,
+                        a list of colors, or an instance of a
                         matplotlib Colormap. Type: import matplotlib.cm; matplotlib.cm.datad.keys()
                         for available colormap names.""",
                 'colorbar': "Include a colorbar indicating the levels (dense matrices only)",
@@ -162,13 +162,13 @@
         options = self.options()
         cmap = get_cmap(options.pop('cmap',None))
         origin=options['origin']
-        
+
         norm=options['norm']
 
         if norm=='value':
             import matplotlib
             norm=matplotlib.colors.NoNorm()
-            
+
         if options['subdivisions']:
             subdiv_options=options['subdivision_options']
             if isinstance(subdiv_options['boundaries'], (list, tuple)):
@@ -181,11 +181,11 @@
             else:
                 rowstyle=subdiv_options['style']
                 colstyle=subdiv_options['style']
-            if rowstyle is None: 
+            if rowstyle is None:
                 rowstyle=dict()
             if colstyle is None:
                 colstyle=dict()
-                
+
             # Make line objects for subdivisions
             from line import line2d
             lim=self.get_minmax_data()
@@ -196,7 +196,7 @@
             for x in colsub:
                 l=line2d([(x-0.5, lim['ymin']), (x-0.5, lim['ymax'])], **colstyle)[0]
                 l._render_on_subplot(subplot)
-            
+
         if hasattr(self.xy_data_array, 'tocoo'):
             # Sparse matrix -- use spy
             opts=options.copy()
@@ -230,13 +230,13 @@
 
 @suboptions('colorbar', orientation='vertical', format=None)
 @suboptions('subdivision',boundaries=None, style=None)
-@options(cmap='gray',marker='.',frame=True, axes=False, norm=None, 
+@options(cmap='gray',marker='.',frame=True, axes=False, norm=None,
          vmin=None, vmax=None, origin='upper',ticks_integer=True,
          subdivisions=False, colorbar=False)
 def matrix_plot(mat, **options):
     r"""
     A plot of a given matrix or 2D array.
-    
+
     If the matrix is dense, each matrix element is given a different
     color value depending on its relative size compared to the other
     elements in the matrix.  If the matrix is sparse, colors only
@@ -261,7 +261,7 @@
       for available colormap names.
 
     - ``colorbar`` -- boolean (default: False) Show a colorbar or not (dense matrices only).
-    
+
       The following options are used to adjust the style and placement
       of colorbars.  They have no effect if a colorbar is not shown.
 
@@ -295,16 +295,16 @@
       ``[row_subdivisions, column_subdivisions]``, which specifies
       the row and column subdivisions to use.  If not specified,
       defaults to the matrix subdivisions
-    
+
     - ``subdivision_style`` - a dictionary of properties passed
       on to the :func:`~sage.plot.line.line2d` command for plotting
-      subdivisions.  If this is a two-element list or tuple, then it 
+      subdivisions.  If this is a two-element list or tuple, then it
       specifies the styles of row and column divisions, respectively.
 
     EXAMPLES:
-    
+
     A matrix over `\ZZ` colored with different grey levels::
-    
+
         sage: matrix_plot(matrix([[1,3,5,1],[2,4,5,6],[1,3,5,7]]))
 
     Here we make a random matrix over `\RR` and use ``cmap='hsv'``
@@ -330,18 +330,18 @@
 
     We can also specify a norm function of 'value', which means that
     there is no scaling performed::
-    
+
         sage: matrix_plot(random_matrix(ZZ,10)*.05, norm='value', colorbar=True)
 
     Matrix subdivisions can be plotted as well::
-    
+
         sage: m=random_matrix(RR,10)
         sage: m.subdivide([2,4],[6,8])
         sage: matrix_plot(m, subdivisions=True, subdivision_style=dict(color='red',thickness=3))
-    
+
     You can also specify your own subdivisions and separate styles
     for row or column subdivisions::
-    
+
         sage: m=random_matrix(RR,10)
         sage: matrix_plot(m, subdivisions=True, subdivision_boundaries=[[2,4],[6,8]], subdivision_style=[dict(color='red',thickness=3),dict(linestyle='--',thickness=6)])
 
@@ -458,7 +458,7 @@
                 data = np.asarray([d for _,d in entries], dtype=float)
             except:
                 raise ValueError, "can not convert entries to floating point numbers"
-            positions = np.asarray([[row for (row,col),_ in entries], 
+            positions = np.asarray([[row for (row,col),_ in entries],
                                     [col for (row,col),_ in entries]], dtype=int)
             mat = scipysparse.coo_matrix((data,positions), shape=(mat.nrows(), mat.ncols()))
         else:
diff --git a/sage/plot/misc.py b/sage/plot/misc.py
--- a/sage/plot/misc.py
+++ b/sage/plot/misc.py
@@ -23,9 +23,9 @@
     and make the functions fast_callable.
 
     INPUT:
-    
+
     -  ``funcs`` - a function, or a list, tuple, or vector of functions
-    
+
     - ``ranges`` - a list of ranges.  A range can be a 2-tuple of
       numbers specifying the minimum and maximum, or a 3-tuple giving
       the variable explicitly.
@@ -33,14 +33,14 @@
     - ``plot_points`` - a tuple of integers specifying the number of
       plot points for each range.  If a single number is specified, it
       will be the value for all ranges.  This defaults to 2.
-     
+
     - ``return_vars`` - (default False) If True, return the variables,
       in order.
-    
-    
+
+
     OUTPUT:
-    
-    
+
+
     - ``fast_funcs`` - if only one function passed, then a fast
        callable function.  If funcs is a list or tuple, then a tuple
        of fast callable functions is returned.
@@ -50,9 +50,9 @@
        range_step) such that ``srange(range_min, range_max,
        range_step, include_endpoint=True)`` gives the correct points
        for evaluation.
-    
+
     EXAMPLES::
-    
+
         sage: x,y,z=var('x,y,z')
         sage: f(x,y)=x+y-z
         sage: g(x,y)=x+y
@@ -123,12 +123,12 @@
         plot_points = [plot_points]*len(ranges)
     elif len(plot_points)!=nargs:
         raise ValueError, "plot_points must be either an integer or a list of integers, one for each range"
-        
+
     plot_points = [int(p) if p>=2 else 2 for p in plot_points]
     range_steps = [abs(range[1] - range[0])/(p-1) for range, p in zip(ranges, plot_points)]
     if min(range_steps) == float(0):
         raise ValueError, "plot start point and end point must be different"
-    
+
     options={}
     if nargs==1:
         options['expect_one_var']=True
@@ -142,19 +142,19 @@
         return fast_float(funcs, *vars,**options), [tuple(range+[range_step]) for range,range_step in zip(ranges, range_steps)], vars
     else:
         return fast_float(funcs, *vars,**options), [tuple(range+[range_step]) for range,range_step in zip(ranges, range_steps)]
-        
+
 
 def unify_arguments(funcs):
     """
     Returns a tuple of variables of the functions, as well as the
     number of "free" variables (i.e., variables that defined in a
     callable function).
-    
+
     INPUT:
-    
+
     - ``funcs`` -- a list of functions; these can be symbolic
             expressions, polynomials, etc
-    
+
     OUTPUT: functions, expected arguments
 
     - A tuple of variables in the functions
@@ -176,7 +176,7 @@
         sage: sage.plot.misc.unify_arguments((h,z))
         ((y, z), (z,))
         sage: sage.plot.misc.unify_arguments((x+y,x-y))
-        ((x, y), (x, y)) 
+        ((x, y), (x, y))
     """
     from sage.symbolic.callable import is_CallableSymbolicExpression
 
@@ -191,7 +191,7 @@
             vars.update(f_args)
         else:
             f_args=set()
-            
+
         try:
             free_vars = set(f.variables()).difference(f_args)
             vars.update(free_vars)
@@ -209,7 +209,7 @@
     Function for internal use in formatting ticks on axes with
     nice-looking multiples of various symbolic constants, such
     as `\pi` or `e`.  Should only be used via keyword argument
-    `tick_formatter` in :meth:`plot.show`.  See documentation 
+    `tick_formatter` in :meth:`plot.show`.  See documentation
     for the matplotlib.ticker module for more details.
 
     EXAMPLES:
@@ -218,7 +218,7 @@
 
         sage: plot(sin(x), (x,0,2*pi), ticks=pi/3, tick_formatter=pi)
 
-    Here is an unintended use, which yields unexpected (and probably 
+    Here is an unintended use, which yields unexpected (and probably
     undesired) results::
 
         sage: plot(x^2, (x, -2, 2), tick_formatter=pi)
diff --git a/sage/plot/plot.py b/sage/plot/plot.py
--- a/sage/plot/plot.py
+++ b/sage/plot/plot.py
@@ -86,7 +86,7 @@
     sage: circle((1,1), 1) + plot(x^2, (x,0,5))
 
 Notice that the aspect ratio of the above plot makes the plot very tall because
-the plot adopts the default aspect ratio of the circle (to make the circle appear 
+the plot adopts the default aspect ratio of the circle (to make the circle appear
 like a circle).  We can change the aspect ratio to be what we normally expect for a plot
 by explicitly asking for an 'automatic' aspect ratio::
 
@@ -347,7 +347,7 @@
 
 from graphics import Graphics, GraphicsArray
 
-#Currently not used - see comment immediately above about 
+#Currently not used - see comment immediately above about
 #figure.canvas.mpl_connect('draw_event', pad_for_tick_labels)
 # TODO - figure out how to use this, add documentation
 #def pad_for_tick_labels(event):
@@ -370,17 +370,17 @@
 #            bbox = label.get_window_extent()
 #            bboxi = bbox.inverse_transformed(figure.transFigure)
 #            bboxes.append(bboxi)
-#    
+#
 #    # this is the bbox that bounds all the bboxes, again in relative
 #    # figure coords
 #    bbox = mtransforms.Bbox.union(bboxes)
 #    adjusted=adjust_figure_to_contain_bbox(figure,bbox)
-#    
+#
 #    if adjusted:
 #        figure.canvas.draw()
 #    return False
 #
-#Currently not used - see comment above about 
+#Currently not used - see comment above about
 #figure.canvas.mpl_connect('draw_event', pad_for_tick_labels)
 # TODO - figure out how to use this, add documentation
 #def adjust_figure_to_contain_bbox(fig, bbox,pad=1.1):
@@ -407,7 +407,7 @@
 #        top-=(bbox.ymax-1)*pad
 #        adjusted=True
 #
-#    if left<right and bottom<top:    
+#    if left<right and bottom<top:
 #        fig.subplots_adjust(left=left, bottom=bottom, right=right, top=top)
 #        return adjusted
 #    else:
@@ -421,9 +421,9 @@
     passes the rest on to a specified formatter.
 
     EXAMPLES:
-    
+
     This example is almost straight from a matplotlib example.
-    
+
     ::
 
         sage: from sage.plot.plot import SelectiveFormatter
@@ -440,7 +440,7 @@
     """
     global _SelectiveFormatterClass
     if _SelectiveFormatterClass is None:
-    
+
         from matplotlib.ticker import Formatter
 
         class _SelectiveFormatterClass(Formatter):
@@ -474,7 +474,7 @@
             def set_locs(self, locs):
                 """
                 Set the locations for the ticks that are not skipped.
-                
+
                 EXAMPLES::
                     sage: from sage.plot.plot import SelectiveFormatter
                     sage: import matplotlib.ticker
@@ -492,25 +492,25 @@
                     sage: import matplotlib.ticker
                     sage: formatter=SelectiveFormatter(matplotlib.ticker.FixedFormatter(['a','b']),skip_values=[0,2])
                     sage: [formatter(i,1) for i in range(10)]
-                    ['', 'b', '', 'b', 'b', 'b', 'b', 'b', 'b', 'b']            
+                    ['', 'b', '', 'b', 'b', 'b', 'b', 'b', 'b', 'b']
                 """
                 if x in self.skip_values:
                     return ''
                 else:
                     return self.formatter(x, *args, **kwds)
-                    
+
     return _SelectiveFormatterClass(formatter, skip_values)
 
 
 def xydata_from_point_list(points):
-    r""" 
+    r"""
     Returns two lists (xdata, ydata), each coerced to a list of floats,
     which correspond to the x-coordinates and the y-coordinates of the
     points.
-    
+
     The points parameter can be a list of 2-tuples or some object that
     yields a list of one or two numbers.
-    
+
     This function can potentially be very slow for large point sets.
 
     TESTS::
@@ -543,13 +543,13 @@
             points = [[float(z) for z in points]]
         except TypeError:
             pass
-    
+
     if len(points)>0 and len(list(points[0]))!=2:
         raise ValueError, "points must have 2 coordinates in a 2d line"
 
-    
+
     xdata = [float(z[0]) for z in points]
-    ydata = [float(z[1]) for z in points]            
+    ydata = [float(z[1]) for z in points]
 
     return xdata, ydata
 
@@ -560,43 +560,43 @@
 def plot(funcs, *args, **kwds):
     r"""
     Use plot by writing
-    
+
     ``plot(X, ...)``
-    
+
     where `X` is a Sage object (or list of Sage objects) that
     either is callable and returns numbers that can be coerced to
     floats, or has a plot method that returns a
     ``GraphicPrimitive`` object.
-    
+
     There are many other specialized 2D plot commands available
-    in Sage, such as ``plot_slope_field``, as well as various 
-    graphics primitives like Arrow; type ``sage.plot.plot?`` for 
+    in Sage, such as ``plot_slope_field``, as well as various
+    graphics primitives like Arrow; type ``sage.plot.plot?`` for
     a current list.
 
     Type ``plot.options`` for a dictionary of the default
     options for plots. You can change this to change the defaults for
     all future plots. Use ``plot.reset()`` to reset to the
     default options.
-    
-    PLOT OPTIONS: 
+
+    PLOT OPTIONS:
 
     - ``plot_points`` - (default: 200) the minimal number of plot points.
 
     - ``adaptive_recursion`` - (default: 5) how many levels of recursion to go
-      before giving up when doing adaptive refinement.  Setting this to 0 
+      before giving up when doing adaptive refinement.  Setting this to 0
       disables adaptive refinement.
 
     - ``adaptive_tolerance`` - (default: 0.01) how large a difference should be
       before the adaptive refinement code considers it significant.  See the
-      documentation further below for more information, starting at "the 
+      documentation further below for more information, starting at "the
       algorithm used to insert".
-    
-    - ``xmin`` - starting x value 
-
-    - ``xmax`` - ending x value 
-
-    - ``color`` - an RGB tuple (r,g,b) with each of r,g,b between 0 and 1, 
-      or a color name as a string (e.g., 'purple'), or an HTML color 
+
+    - ``xmin`` - starting x value
+
+    - ``xmax`` - ending x value
+
+    - ``color`` - an RGB tuple (r,g,b) with each of r,g,b between 0 and 1,
+      or a color name as a string (e.g., 'purple'), or an HTML color
       such as '#aaff0b'.
 
     - ``detect_poles`` - (Default: False) If set to True poles are detected.
@@ -604,24 +604,24 @@
 
     - ``legend_label`` - the label for this item in the legend
 
-    APPEARANCE OPTIONS: 
+    APPEARANCE OPTIONS:
 
     The following options affect the appearance of
     the line through the points on the graph of `X` (these are
     the same as for the line function):
-    
+
     INPUT:
-    
+
     - ``alpha`` - How transparent the line is
 
     - ``thickness`` - How thick the line is
-        
+
     - ``rgbcolor`` - The color as an RGB tuple
-        
+
     - ``hue`` - The color given as a hue
 
     Any MATPLOTLIB line option may also be passed in.  E.g.,
-    
+
     - ``linestyle`` - The style of the line, which is one of
        - ``"-"`` (solid) -- default
        - ``"--"`` (dashed)
@@ -638,7 +638,7 @@
          horizontal lines)
        - ``"steps-post"`` (step function; horizontal line is to the
          right of point)
-        
+
     - ``marker``  - The style of the markers, which is one of
        - ``"None"`` or ``" "`` or ``""`` (nothing) -- default
        - ``","`` (pixel), ``"."`` (point)
@@ -651,7 +651,7 @@
        - ``0`` (tick left), ``1`` (tick right), ``2`` (tick up), ``3`` (tick down)
        - ``4`` (caret left), ``5`` (caret right), ``6`` (caret up), ``7`` (caret down)
        - ``"$...$"`` (math TeX string)
-       
+
     - ``markersize`` - the size of the marker in points
 
     - ``markeredgecolor`` -- the color of the marker edge
@@ -666,17 +666,17 @@
     FILLING OPTIONS:
 
     - ``fill`` - (Default: False) One of:
-                
+
       - "axis" or True: Fill the area between the function and the x-axis.
-                
+
       - "min": Fill the area between the function and its minimal value.
-      
+
       - "max": Fill the area between the function and its maximal value.
-      
+
       - a number c: Fill the area between the function and the horizontal line y = c.
-      
+
       - a function g: Fill the area between the function that is plotted and g.
-      
+
       - a dictionary d (only if a list of functions are plotted):
         The keys of the dictionary should be integers.
         The value of d[i] specifies the fill options for the i-th function in the list.
@@ -686,7 +686,7 @@
 
     - ``fillcolor`` - (default: 'automatic') The color of the fill.
       Either 'automatic' or a color.
-        
+
     - ``fillalpha`` - (default: 0.5) How transparent the fill is.
       A number between 0 and 1.
 
@@ -695,9 +695,9 @@
     points and add small perturbations to them. This reduces the
     possibility of, e.g., sampling sin only at multiples of
     `2\pi`, which would yield a very misleading graph.
-    
+
     EXAMPLES: We plot the sin function::
-    
+
         sage: P = plot(sin, (0,10)); print P
         Graphics object consisting of 1 graphics primitive
         sage: len(P)     # number of graphics primitives
@@ -705,47 +705,47 @@
         sage: len(P[0])  # how many points were computed (random)
         225
         sage: P          # render
-    
+
     ::
-    
+
         sage: P = plot(sin, (0,10), plot_points=10); print P
         Graphics object consisting of 1 graphics primitive
         sage: len(P[0])  # random output
         32
         sage: P          # render
-    
+
     We plot with ``randomize=False``, which makes the initial sample points
     evenly spaced (hence always the same). Adaptive plotting might
     insert other points, however, unless ``adaptive_recursion=0``.
-    
+
     ::
-    
+
         sage: p=plot(1, (x,0,3), plot_points=4, randomize=False, adaptive_recursion=0)
         sage: list(p[0])
         [(0.0, 1.0), (1.0, 1.0), (2.0, 1.0), (3.0, 1.0)]
-    
+
     Some colored functions::
-    
+
         sage: plot(sin, 0, 10, color='purple')
         sage: plot(sin, 0, 10, color='#ff00ff')
-    
+
     We plot several functions together by passing a list of functions
     as input::
-    
+
         sage: plot([sin(n*x) for n in [1..4]], (0, pi))
-        
+
     We can also build a plot step by step from an empty plot::
-    
+
         sage: a = plot([]); a       # passing an empty list returns an empty plot (Graphics() object)
         sage: a += plot(x**2); a    # append another plot
         sage: a += plot(x**3); a    # append yet another plot
-        
-    
+
+
     The function `\sin(1/x)` wiggles wildly near `0`.
     Sage adapts to this and plots extra points near the origin.
-    
+
     ::
-    
+
         sage: plot(sin(1/x), (x, -1, 1))
 
     Via the matplotlib library, Sage makes it easy to tell whether
@@ -762,7 +762,7 @@
         sage: plot(x^2,(x,480,500))  # this one has no scientific notation
         sage: plot(x^2,(x,300,500))  # this one has scientific notation on y-axis
 
-    You can put a legend with ``legend_label`` (the legend is only put 
+    You can put a legend with ``legend_label`` (the legend is only put
     once in the case of multiple functions)::
 
         sage: plot(exp(x), 0, 2, legend_label='$e^x$')
@@ -776,12 +776,12 @@
 
     Note that the independent variable may be omitted if there is no
     ambiguity::
-    
+
         sage: plot(sin(1/x), (-1, 1))
-    
+
     The algorithm used to insert extra points is actually pretty
     simple. On the picture drawn by the lines below::
-    
+
         sage: p = plot(x^2, (-0.5, 1.4)) + line([(0,0), (1,1)], color='green')
         sage: p += line([(0.5, 0.5), (0.5, 0.5^2)], color='purple')
         sage: p += point(((0, 0), (0.5, 0.5), (0.5, 0.5^2), (1, 1)), color='red', pointsize=20)
@@ -790,7 +790,7 @@
         sage: p += text('C', (0.48, 0.57), color='red')
         sage: p += text('D', (0.53, 0.18), color='red')
         sage: p.show(axes=False, xmin=-0.5, xmax=1.4, ymin=0, ymax=2)
-    
+
     You have the function (in blue) and its approximation (in green)
     passing through the points A and B. The algorithm finds the
     midpoint C of AB and computes the distance between C and D. If that
@@ -799,57 +799,57 @@
     added to the curve.  If D is added to the curve, then the
     algorithm is applied recursively to the points A and D, and D and
     B. It is repeated ``adaptive_recursion`` times (5, by default).
-    
+
     The actual sample points are slightly randomized, so the above
     plots may look slightly different each time you draw them.
-    
+
     We draw the graph of an elliptic curve as the union of graphs of 2
     functions.
-    
+
     ::
-    
+
         sage: def h1(x): return abs(sqrt(x^3  - 1))
         sage: def h2(x): return -abs(sqrt(x^3  - 1))
         sage: P = plot([h1, h2], 1,4)
         sage: P          # show the result
-    
+
     We can also directly plot the elliptic curve::
-    
+
         sage: E = EllipticCurve([0,-1])
         sage: plot(E, (1, 4), color=hue(0.6))
-    
+
     We can change the line style as well::
-    
+
         sage: plot(sin(x), (x, 0, 10), linestyle='-.')
-    
+
     If we have an empty linestyle and specify a marker, we can see the
     points that are actually being plotted::
 
         sage: plot(sin(x), (x,0,10), plot_points=20, linestyle='', marker='.')
 
     The marker can be a TeX symbol as well::
-    
+
         sage: plot(sin(x), (x,0,10), plot_points=20, linestyle='', marker=r'$\checkmark$')
 
     Sage currently ignores points that cannot be evaluated
-    
+
     ::
-    
+
         sage: set_verbose(-1)
         sage: plot(-x*log(x), (x,0,1))  # this works fine since the failed endpoint is just skipped.
         sage: set_verbose(0)
-    
+
     This prints out a warning and plots where it can (we turn off the
     warning by setting the verbose mode temporarily to -1.)
-    
+
     ::
-    
+
         sage: set_verbose(-1)
         sage: plot(x^(1/3), (x,-1,1))
         sage: set_verbose(0)
 
     To plot the negative real cube root, use something like the following::
-    
+
         sage: plot(lambda x : RR(x).nth_root(3), (x,-1, 1))
 
     We can detect the poles of a function::
@@ -861,7 +861,7 @@
         sage: plot(gamma, (-3, 4), detect_poles = 'show').show(ymin = -5, ymax = 5)
 
     The basic options for filling a plot::
-    
+
         sage: p1 = plot(sin(x), -pi, pi, fill = 'axis')
         sage: p2 = plot(sin(x), -pi, pi, fill = 'min')
         sage: p3 = plot(sin(x), -pi, pi, fill = 'max')
@@ -871,11 +871,11 @@
         sage: plot([sin(x), cos(2*x)*sin(4*x)], -pi, pi, fill = {0: 1}, fillcolor = 'red', fillalpha = 1)
 
     A example about the growth of prime numbers::
-    
+
         sage: plot(1.13*log(x), 1, 100, fill = lambda x: nth_prime(x)/floor(x), fillcolor = 'red')
 
     Fill the area between a function and its asymptote::
-    
+
         sage: f = (2*x^3+2*x-1)/((x-2)*(x+1))
         sage: plot([f, 2*x+2], -7,7, fill = {0: [1]}, fillcolor='#ccc').show(ymin=-20, ymax=20)
 
@@ -891,7 +891,7 @@
         sage: def b(n): return lambda x: bessel_J(n, x) + 0.5*(n-1)
         sage: plot([b(c) for c in [1..5]], 0, 40, fill = dict([(i, [i+1]) for i in [0..3]]))
         sage: plot([b(c) for c in [1..5]], 0, 40, fill = dict([(i, i+1) for i in [0..3]]))
-    
+
     Extra options will get passed on to show(), as long as they are valid::
 
         sage: plot(sin(x^2), (x, -3, 3), axes_labels=['$x$','$y$']) # These labels will be nicely typeset
@@ -902,7 +902,7 @@
         sage: plot(sin(x^2), (x, -3, 3), figsize=[8,2])
         sage: plot(sin(x^2), (x, -3, 3)).show(figsize=[8,2]) # These are equivalent
 
-    This includes options for custom ticks and formatting.  See documentation 
+    This includes options for custom ticks and formatting.  See documentation
     for :meth:`show` for more details.
 
     ::
@@ -936,32 +936,32 @@
         sage: plot(f, (x, -3.5, 3.5), detect_poles = 'show', exclude = [-3..3], ymin = -5, ymax = 5)
 
     TESTS:
-    
+
     We do not randomize the endpoints::
-    
+
         sage: p = plot(x, (x,-1,1))
         sage: p[0].xdata[0] == -1
         True
         sage: p[0].xdata[-1] == 1
         True
-    
+
     We check to make sure that the x/y min/max data get set correctly
     when there are multiple functions.
-    
+
     ::
-    
+
         sage: d = plot([sin(x), cos(x)], 100, 120).get_minmax_data()
         sage: d['xmin']
         100.0
         sage: d['xmax']
-        120.0   
-    
+        120.0
+
     We check various combinations of tuples and functions, ending with
     tests that lambda functions work properly with explicit variable
     declaration, without a tuple.
-    
+
     ::
-    
+
         sage: p = plot(lambda x: x,(x,-1,1))
         sage: p = plot(lambda x: x,-1,1)
         sage: p = plot(x,x,-1,1)
@@ -973,15 +973,15 @@
         sage: p = plot(lambda x: 1/x,x,-1,1)
         sage: f(x) = sin(x+3)-.1*x^3
         sage: p = plot(lambda x: f(x),x,-1,1)
-    
+
     We check to handle cases where the function gets evaluated at a
     point which causes an 'inf' or '-inf' result to be produced.
-    
+
     ::
-    
+
         sage: p = plot(1/x, 0, 1)
         sage: p = plot(-1/x, 0, 1)
-    
+
     Bad options now give better errors::
 
         sage: P = plot(sin(1/x), (x,-1,3), foo=10)
@@ -1316,20 +1316,20 @@
 
     In the 2d case, :func:`parametric_plot` is equivalent to the :func:`plot` command
     with the option ``parametric=True``.  In the 3d case, :func:`parametric_plot`
-    is equivalent to :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`. 
+    is equivalent to :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`.
     See each of these functions for more help and examples.
 
     INPUT:
-    
-    
+
+
     -  ``funcs`` - 2 or 3-tuple of functions, or a vector of dimension 2 or 3.
-    
+
     -  ``other options`` - passed to :func:`plot` or :func:`~sage.plot.plot3d.parametric_plot3d.parametric_plot3d`
-    
-    
-    EXAMPLES: We draw some 2d parametric plots.  Note that the default aspect ratio 
+
+
+    EXAMPLES: We draw some 2d parametric plots.  Note that the default aspect ratio
     is 1, so that circles look like circles. ::
-    
+
         sage: t = var('t')
         sage: parametric_plot( (cos(t), sin(t)), (t, 0, 2*pi))
 
@@ -1342,31 +1342,31 @@
         sage: parametric_plot((1, t), (t, 0, 4))
 
     Note that in parametric_plot, there is only fill or no fill.
-    
+
     ::
-    
+
         sage: parametric_plot((t, t^2), (t, -4, 4), fill = True)
 
     A filled Hypotrochoid::
-    
+
         sage: parametric_plot([cos(x) + 2 * cos(x/4), sin(x) - 2 * sin(x/4)], (x,0, 8*pi), fill = True)
-    
+
         sage: parametric_plot( (5*cos(x), 5*sin(x), x), (x,-12, 12), plot_points=150, color="red")
 
         sage: y=var('y')
         sage: parametric_plot( (5*cos(x), x*y, cos(x*y)), (x, -4,4), (y,-4,4))
-        
+
         sage: t=var('t')
         sage: parametric_plot( vector((sin(t), sin(2*t))), (t, 0, 2*pi), color='green')
-        sage: parametric_plot( vector([t, t+1, t^2]), (t, 0, 1)) 
+        sage: parametric_plot( vector([t, t+1, t^2]), (t, 0, 1))
 
     TESTS::
-    
+
         sage: parametric_plot((x, t^2), (x, -4, 4))
         Traceback (most recent call last):
         ...
         ValueError: there are more variables than variable ranges
-    
+
         sage: parametric_plot((1, x+t), (x, -4, 4))
         Traceback (most recent call last):
         ...
@@ -1407,7 +1407,7 @@
         raise ValueError, "there are more variables than variable ranges"
 
     if num_funcs == 2 and num_ranges == 1:
-        kwargs['parametric'] = True                    
+        kwargs['parametric'] = True
         return plot(funcs, *args, **kwargs)
     elif (num_funcs == 3 and num_ranges <= 2):
         return sage.plot.plot3d.parametric_plot3d.parametric_plot3d(funcs, *args, **kwargs)
@@ -1431,33 +1431,33 @@
     - other options are passed to plot
 
     EXAMPLES:
-    
+
     Here is a blue 8-leaved petal::
-    
+
         sage: polar_plot(sin(5*x)^2, (x, 0, 2*pi), color='blue')
-    
+
     A red figure-8::
-    
+
         sage: polar_plot(abs(sqrt(1 - sin(x)^2)), (x, 0, 2*pi), color='red')
-    
+
     A green limacon of Pascal::
-    
+
         sage: polar_plot(2 + 2*cos(x), (x, 0, 2*pi), color=hue(0.3))
 
     Several polar plots::
-    
+
         sage: polar_plot([2*sin(x), 2*cos(x)], (x, 0, 2*pi))
 
     A filled spiral::
-    
+
         sage: polar_plot(sqrt, 0, 2 * pi, fill = True)
 
     Fill the area between two functions::
-    
+
         sage: polar_plot(cos(4*x) + 1.5, 0, 2*pi, fill=0.5 * cos(4*x) + 2.5, fillcolor='orange')
 
     Fill the area between several spirals::
-    
+
         sage: polar_plot([(1.2+k*0.2)*log(x) for k in range(6)], 1, 3 * pi, fill = {0: [1], 2: [3], 4: [5]})
 
     Exclude points at discontinuities::
@@ -1478,7 +1478,7 @@
     ``list_plot`` forms a list of tuples `(i, x_i)` where `i` goes from
     0 to ``len(data)-1`` and `x_i` is the `i`-th data value, and puts
     points at those tuple values.
-    
+
     ``list_plot`` will plot a list of complex numbers in the obvious
     way; any numbers for which
     :func:`CC()<sage.rings.complex_field.ComplexField>` makes sense will
@@ -1498,16 +1498,16 @@
     list_plot. Doing so will plot nothing (returning an empty plot).
 
     EXAMPLES::
-    
+
         sage: list_plot([i^2 for i in range(5)])
-    
+
     Here are a bunch of random red points::
-    
+
         sage: r = [(random(),random()) for _ in range(20)]
         sage: list_plot(r,color='red')
-    
+
     This gives all the random points joined in a purple line::
-    
+
         sage: list_plot(r, plotjoined=True, color='purple')
 
     Plot a list of complex numbers::
@@ -1550,9 +1550,9 @@
     TESTS:
 
     We check to see that the x/y min/max data are set correctly.
-    
+
     ::
-    
+
         sage: d = list_plot([(100,100), (120, 120)]).get_minmax_data()
         sage: d['xmin']
         100.0
@@ -1596,9 +1596,9 @@
     """
     Given a list or tuple or iterable v, coerce each element of v to a
     float and make a list out of the result.
-    
+
     EXAMPLES::
-    
+
         sage: from sage.plot.plot import to_float_list
         sage: to_float_list([1,1/2,3])
         [1.0, 0.5, 3.0]
@@ -1656,7 +1656,7 @@
     # First, make it have the right length.
     for i in xrange(n*m - len(v)):
         v.append(G)
-        
+
     # Next, create a list of lists out of it.
     L = []
     k = 0
@@ -1737,25 +1737,25 @@
 def var_and_list_of_values(v, plot_points):
     """
     INPUT:
-    
-    
+
+
     -  ``v`` - (v0, v1) or (var, v0, v1); if the former
        return the range of values between v0 and v1 taking plot_points
        steps; if var is given, also return var.
-    
+
     -  ``plot_points`` - integer = 2 (the endpoints)
-    
-    
+
+
     OUTPUT:
-    
-    
+
+
     -  ``var`` - a variable or None
-    
+
     -  ``list`` - a list of floats
-    
-    
+
+
     EXAMPLES::
-    
+
         sage: from sage.plot.plot import var_and_list_of_values
         sage: var_and_list_of_values((var('theta'), 2, 5),  5)
         doctest:...: DeprecationWarning: var_and_list_of_values is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable
@@ -1802,34 +1802,34 @@
     conventions which make it more generally applicable.
 
     INPUT:
-    
-    
+
+
     -  ``v`` - a list of functions
-    
+
     -  ``xrange`` - 2 or 3 tuple (if 3, first is a
        variable)
-    
+
     -  ``yrange`` - 2 or 3 tuple
-    
+
     -  ``plot_points`` - a positive integer
-    
-    
+
+
     OUTPUT:
-    
-    
+
+
     -  ``g`` - tuple of fast callable functions
-    
+
     -  ``xstep`` - step size in xdirection
-    
+
     -  ``ystep`` - step size in ydirection
-    
+
     -  ``xrange`` - tuple of 2 floats
-    
+
     -  ``yrange`` - tuple of 2 floats
-    
-    
+
+
     EXAMPLES::
-    
+
         sage: x,y = var('x,y')
         sage: sage.plot.plot.setup_for_eval_on_grid([x^2 + y^2], (x,0,5), (y,0,pi), 11)
         doctest:...: DeprecationWarning: sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable
@@ -1842,7 +1842,7 @@
     We always plot at least two points; one at the beginning and one at the end of the ranges.
 
     ::
-    
+
         sage: sage.plot.plot.setup_for_eval_on_grid([x^2+y^2], (x,0,1), (y,-1,1), 1)
         ([<sage.ext... object at ...>],
         1.0,
@@ -1850,7 +1850,7 @@
         (0.0, 1.0),
         (-1.0, 1.0))
 
-        
+
     """
     from sage.misc.misc import deprecation
     deprecation("sage.plot.plot.setup_for_eval_on_grid is deprecated.  Please use sage.plot.misc.setup_for_eval_on_grid; note that that function has slightly different calling and return conventions which make it more generally applicable")
@@ -1863,14 +1863,14 @@
 def minmax_data(xdata, ydata, dict=False):
     """
     Returns the minimums and maximums of xdata and ydata.
-    
+
     If dict is False, then minmax_data returns the tuple (xmin, xmax,
     ymin, ymax); otherwise, it returns a dictionary whose keys are
     'xmin', 'xmax', 'ymin', and 'ymax' and whose values are the
     corresponding values.
-    
+
     EXAMPLES::
-    
+
         sage: from sage.plot.plot import minmax_data
         sage: minmax_data([], [])
         (-1, 1, -1, 1)
@@ -1894,33 +1894,33 @@
     r"""
     The adaptive refinement algorithm for plotting a function f. See
     the docstring for plot for a description of the algorithm.
-    
+
     INPUT:
-    
-    
+
+
     -  ``f`` - a function of one variable
-    
+
     -  ``p1, p2`` - two points to refine between
-    
+
     -  ``adaptive_recursion`` - (default: 5) how many
        levels of recursion to go before giving up when doing adaptive
        refinement. Setting this to 0 disables adaptive refinement.
-    
+
     -  ``adaptive_tolerance`` - (default: 0.01) how large
        a relative difference should be before the adaptive refinement
        code considers it significant; see documentation for generate_plot_points
        for more information.  See the documentation for plot() for more
        information on how the adaptive refinement algorithm works.
-    
+
     OUTPUT:
-    
-    
+
+
     -  ``list`` - a list of points to insert between p1 and
        p2 to get a better linear approximation between them
-    
-    
+
+
     TESTS::
-    
+
         sage: from sage.plot.plot import adaptive_refinement
         sage: adaptive_refinement(sin, (0,0), (pi,0), adaptive_tolerance=0.01, adaptive_recursion=0)
         []
@@ -1929,11 +1929,11 @@
 
     This shows that lowering adaptive_tolerance and raising
     adaptive_recursion both increase the number of subdivision
-    points, though which one creates more points is heavily 
+    points, though which one creates more points is heavily
     dependent upon the function being plotted.
 
     ::
-    
+
         sage: x = var('x')
         sage: f(x) = sin(1/x)
         sage: n1 = len(adaptive_refinement(f, (0,0), (pi,0), adaptive_tolerance=0.01)); n1
@@ -1961,7 +1961,7 @@
         # give up for this branch
         return []
 
-    # this distance calculation is not perfect. 
+    # this distance calculation is not perfect.
     if abs((p1[1] + p2[1])/2.0 - y) > adaptive_tolerance:
         return adaptive_refinement(f, p1, (x, y),
                     adaptive_tolerance=adaptive_tolerance,
@@ -1979,32 +1979,32 @@
     r"""
     Calculate plot points for a function f in the interval xrange.  The
     adaptive refinement algorithm is also automatically invoked with a
-    *relative* adaptive tolerance of adaptive_tolerance; see below. 
+    *relative* adaptive tolerance of adaptive_tolerance; see below.
 
     INPUT:
-        
+
     - ``f`` - a function of one variable
-        
+
     - ``p1, p2`` - two points to refine between
-        
+
     - ``plot_points`` - (default: 5) the minimal number of plot points. (Note
       however that in any actual plot a number is passed to this, with default
       value 200.)
 
     - ``adaptive_recursion`` - (default: 5) how many levels of recursion to go
-      before giving up when doing adaptive refinement.  Setting this to 0 
+      before giving up when doing adaptive refinement.  Setting this to 0
       disables adaptive refinement.
 
     - ``adaptive_tolerance`` - (default: 0.01) how large the relative difference
       should be before the adaptive refinement code considers it significant.  If
       the actual difference is greater than adaptive_tolerance*delta, where delta
       is the initial subinterval size for the given xrange and plot_points, then
-      the algorithm will consider it significant. 
+      the algorithm will consider it significant.
 
     - ``initial_points`` - (default: None) a list of points that should be evaluated.
 
     OUTPUT:
-        
+
     - a list of points (x, f(x)) in the interval xrange, which approximate
       the function f.
 
@@ -2126,7 +2126,7 @@
     adaptive_recursion = int(adaptive_recursion)
 
     while i < len(data) - 1:
-       for p in adaptive_refinement(f, data[i], data[i+1], 
+       for p in adaptive_refinement(f, data[i], data[i+1],
                                      adaptive_tolerance=adaptive_tolerance,
                                      adaptive_recursion=adaptive_recursion):
             data.insert(i+1, p)
diff --git a/sage/plot/plot3d/examples.py b/sage/plot/plot3d/examples.py
--- a/sage/plot/plot3d/examples.py
+++ b/sage/plot/plot3d/examples.py
@@ -4,10 +4,10 @@
 EXAMPLES::
 
     sage: x, y = var('x y')
-    sage: W = plot3d(sin(pi*((x)^2+(y)^2))/2,(x,-1,1),(y,-1,1), frame=False, color='purple', opacity=0.8) 
+    sage: W = plot3d(sin(pi*((x)^2+(y)^2))/2,(x,-1,1),(y,-1,1), frame=False, color='purple', opacity=0.8)
     sage: S = sphere((0,0,0),size=0.3, color='red', aspect_ratio=[1,1,1])
     sage: show(W + S, figsize=8)
 """
-   
 
 
+
diff --git a/sage/plot/plot3d/implicit_plot3d.py b/sage/plot/plot3d/implicit_plot3d.py
--- a/sage/plot/plot3d/implicit_plot3d.py
+++ b/sage/plot/plot3d/implicit_plot3d.py
@@ -30,7 +30,7 @@
        callable. Only segments of the surface where region(x,y,z) returns a
        number >0 will be included in the plot. (Note that returning a Python
        boolean is acceptable, since True == 1 and False == 0).
-    
+
     EXAMPLES::
 
         sage: var('x,y,z')
@@ -48,7 +48,7 @@
     A very pretty example from http://iat.ubalt.edu/summers/math/platsol.htm::
 
         sage: T = RDF(golden_ratio)
-        sage: p = 2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x)) 
+        sage: p = 2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x))
         sage: r = 4.77
         sage: implicit_plot3d(p, (x, -r, r), (y, -r, r), (z, -r, r), plot_points=40).show(viewer='tachyon')
 
@@ -64,7 +64,7 @@
     The same examples also work with the default Jmol viewer; for example::
 
         sage: T = RDF(golden_ratio)
-        sage: p = 2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x)) 
+        sage: p = 2 - (cos(x + T*y) + cos(x - T*y) + cos(y + T*z) + cos(y - T*z) + cos(z - T*x) + cos(z + T*x))
         sage: r = 4.77
         sage: implicit_plot3d(p, (x, -r, r), (y, -r, r), (z, -r, r), plot_points=40).show()
 
@@ -79,11 +79,11 @@
         sage: gy = lambda x, y, z: -(x^2 + 2*y + z^2)
         sage: gz = lambda x, y, z: -(x^2 + y^2 + 2*z)
         sage: implicit_plot3d(x^2+y^2+z^2, (x, -2, 2), (y, -2, 2), (z, -2, 2), contour=4, \
-        ...       plot_points=40, smooth=True, gradient=(gx, gy, gz)).show(viewer='tachyon') 
+        ...       plot_points=40, smooth=True, gradient=(gx, gy, gz)).show(viewer='tachyon')
 
     A graph of two metaballs interacting with each other::
 
-        sage: def metaball(x0, y0, z0): return 1 / ((x-x0)^2 + (y-y0)^2 + (z-z0)^2)    
+        sage: def metaball(x0, y0, z0): return 1 / ((x-x0)^2 + (y-y0)^2 + (z-z0)^2)
         sage: implicit_plot3d(metaball(-0.6, 0, 0) + metaball(0.6, 0, 0), (x, -2, 2), (y, -2, 2), (z, -2, 2), plot_points=60, contour=2)
 
     MANY MORE EXAMPLES:
@@ -93,115 +93,115 @@
         sage: implicit_plot3d(x^3 + y^2 - z^2, (x, -2, 2), (y, -2, 2), (z, -2, 2), plot_points=60, contour=0)
 
     A smooth surface with six radial openings::
-    
+
         sage: implicit_plot3d(-(cos(x) + cos(y) + cos(z)), (x, -4, 4), (y, -4, 4), (z, -4, 4))
 
     A cube composed of eight conjoined blobs::
-    
+
         sage: implicit_plot3d(x^2 + y ^2 + z^2 +cos(4*x)+cos(4*y)+cos(4*z)-0.2, (x, -2, 2), (y, -2, 2), (z, -2, 2))
 
     A variation of the blob cube featuring heterogeneously sized blobs::
-    
+
         sage: implicit_plot3d(x^2 + y ^2 + z^2 +sin(4*x) + sin(4*y) + sin(4*z) -1, (x, -2, 2), (y, -2, 2), (z, -2, 2))
 
     A klein bottle::
-    
+
         sage: implicit_plot3d((x^2+y^2+z^2+2*y-1)*((x^2+y^2+z^2-2*y-1)^2-8*z^2)+16*x*z*(x^2+y^2+z^2-2*y-1), (x, -3, 3), (y, -3.1, 3.1), (z, -4, 4))
 
     A lemniscate::
-    
+
         sage: implicit_plot3d(4*x^2*(x^2+y^2+z^2+z)+y^2*(y^2+z^2-1), (x, -0.5, 0.5), (y, -1, 1), (z, -1, 1))
 
     Drope::
-    
+
         sage: implicit_plot3d(z - 4*x*exp(-x^2-y^2), (x, -2, 2), (y, -2, 2), (z, -1.7, 1.7))
 
     A cube with a circular aperture on each face::
-    
+
         sage: implicit_plot3d(((1/2.3)^2 *(x^2 + y^2 + z^2))^-6 + ( (1/2)^8 * (x^8 + y^8 + z^8) )^6 -1, (x, -2, 2), (y, -2, 2), (z, -2, 2))
 
     A simple hyperbolic surface::
-    
+
         sage: implicit_plot3d(x*x + y - z*z, (x, -1, 1), (y, -1, 1), (z, -1, 1))
 
     A hyperboloid::
-    
+
         sage: implicit_plot3d(x^2 + y^2 - z^2 -0.3, (x, -2, 2), (y, -2, 2), (z, -1.8, 1.8))
 
     Duplin cycloid::
-    
+
         sage: implicit_plot3d((2^2 - 0^2 - (2 + 2.1)^2) * (2^2 - 0^2 - (2 - 2.1)^2)*(x^4+y^4+z^4)+ 2*((2^2 - 0^2 - (2 + 2.1)^2 )*(2^2 - 0^2 - (2 - 2.1)^2)* (x^2 * y^2+x^2 * z^2+y^2 * z^2))+2* 2^2 *((-0^2-2^2+2^2+2.1^2)* (2 *x *2+2* y* 0-2^2)-4*0 *2.1^2 *y)*(x^2+y^2+z^2)+ 4 * 2^4 * (2 *x+0 *y)* (-2^2+0 * y+2 * x)+4* 2^4 * 2.1^2 * y^2+2^8, (x, -2, 2.2), (y, -2, 2), (z, -1.3, 1.3))
 
     Sinus::
-    
+
         sage: implicit_plot3d(sin(pi*((x)^2+(y)^2))/2 +z, (x, -1, 1), (y, -1, 1), (z, -1, 1))
 
     A torus::
-    
+
         sage: implicit_plot3d((sqrt(x*x+y*y)-3)^2 + z*z - 1, (x, -4, 4), (y, -4, 4), (z, -1, 1))
 
     An octahedron::
-    
+
         sage: implicit_plot3d(abs(x)+abs(y)+abs(z) - 1, (x, -1, 1), (y, -1, 1), (z, -1, 1))
 
     A cube::
-    
+
         sage: implicit_plot3d(x^100 + y^100 + z^100 -1, (x, -2, 2), (y, -2, 2), (z, -2, 2))
 
     Toupie::
-    
+
         sage: implicit_plot3d((sqrt(x*x+y*y)-3)^3 + z*z - 1, (x, -4, 4), (y, -4, 4), (z, -6, 6))
 
     A cube with rounded edges::
-    
+
         sage: implicit_plot3d(x^4 + y^4 + z^4 - (x^2 + y^2 + z^2), (x, -2, 2), (y, -2, 2), (z, -2, 2))
 
     Chmutov::
-    
+
         sage: implicit_plot3d(x^4 + y^4 + z^4 - (x^2 + y^2 + z^2-0.3), (x, -1.5, 1.5), (y, -1.5, 1.5), (z, -1.5, 1.5))
 
     Further Chutmov::
-    
+
         sage: implicit_plot3d(2*(x^2*(3-4*x^2)^2+y^2*(3-4*y^2)^2+z^2*(3-4*z^2)^2) -3, (x, -1.3, 1.3), (y, -1.3, 1.3), (z, -1.3, 1.3))
 
     Clebsch::
-    
+
         sage: implicit_plot3d(81*(x^3+y^3+z^3)-189*(x^2*y+x^2*z+y^2*x+y^2*z+z^2*x+z^2*y) +54*x*y*z+126*(x*y+x*z+y*z)-9*(x^2+y^2+z^2)-9*(x+y+z)+1, (x, -1, 1), (y, -1, 1), (z, -1, 1))
 
     Looks like a water droplet::
-    
+
         sage: implicit_plot3d(x^2 +y^2 -(1-z)*z^2, (x, -1.5, 1.5), (y, -1.5, 1.5), (z, -1, 1))
 
     Sphere in a cage::
-    
+
         sage: implicit_plot3d((x^8 + z^30 + y^8 - (x^4 + z^50 + y^4 -0.3))*(x^2 + y^2 + z^2 -0.5), (x, -1.2, 1.2), (y, -1.3, 1.3), (z, -1.5, 1.5))
 
     Ortho circle::
-    
+
         sage: implicit_plot3d(((x^2 + y^2 - 1)^2 + z^2)* ((y^2 + z^2 - 1)^2 + x^2)* ((z^2 + x^2 - 1)^2 + y^2) - 0.075^2 *(1 + 3* (x^2 + y^2 + z^2)), (x, -1.5, 1.5), (y, -1.5, 1.5), (z, -1.5, 1.5))
 
     Cube sphere::
-    
+
         sage: implicit_plot3d(12 - ((1/2.3)^2 *(x^2 + y^2 + z^2))^-6 - ( (1/2)^8 * (x^8 + y^8 + z^8) )^6, (x, -2, 2), (y, -2, 2), (z, -2, 2))
 
     Two cylinders intersect to make a cross::
-    
+
         sage: implicit_plot3d((x^2 + y^2 - 1) * ( x^2 + z^2 - 1) - 1, (x, -3, 3), (y, -3, 3), (z, -3, 3))
 
     Three cylinders intersect in a similar fashion::
-    
+
         sage: implicit_plot3d((x^2 + y^2 - 1) * ( x^2 + z^2 - 1)* ( y^2 + z^2 - 1) - 1, (x, -3, 3), (y, -3, 3), (z, -3, 3))
 
     A sphere-ish object with twelve holes, four on each XYZ plane::
-    
+
         sage: implicit_plot3d(3*(cos(x) + cos(y) + cos(z)) + 4* cos(x) * cos(y) * cos(z), (x, -3, 3), (y, -3, 3), (z, -3, 3))
 
     A gyroid::
-    
+
         sage: implicit_plot3d(cos(x) * sin(y) + cos(y) * sin(z) + cos(z) * sin(x), (x, -4, 4), (y, -4, 4), (z, -4, 4))
 
     Tetrahedra::
-    
+
         sage: implicit_plot3d((x^2 + y^2 + z^2)^2 + 8*x*y*z - 10*(x^2 + y^2 + z^2) + 25, (x, -4, 4), (y, -4, 4), (z, -4, 4))
 
     TESTS:
diff --git a/sage/plot/plot3d/list_plot3d.py b/sage/plot/plot3d/list_plot3d.py
--- a/sage/plot/plot3d/list_plot3d.py
+++ b/sage/plot/plot3d/list_plot3d.py
@@ -9,120 +9,120 @@
     r"""
     A 3-dimensional plot of a surface defined by the list `v`
     of points in 3-dimensional space.
-    
+
     INPUT:
-    
-    
+
+
     - ``v`` - something that defines a set of points in 3
       space, for example:
 
       - a matrix
 
       - a list of 3-tuples
-    
+
       - a list of lists (all of the same length) - this is treated the same as
         a matrix.
-    
+
     - ``texture`` - (default: "automatic", a solid light blue)
-    
+
     OPTIONAL KEYWORDS:
-    
+
     - ``interpolation_type`` - 'linear', 'nn' (nearest neighbor), 'spline'
-    
+
       'linear' will perform linear interpolation
-    
+
       The option 'nn' will interpolate by averaging the value of the
       nearest neighbors, this produces an interpolating function that is
       smoother than a linear interpolation, it has one derivative
       everywhere except at the sample points.
-    
+
       The option 'spline' interpolates using a bivariate B-spline.
-    
+
       When v is a matrix the default is to use linear interpolation, when
       v is a list of points the default is nearest neighbor.
-    
+
     - ``degree`` - an integer between 1 and 5, controls the degree of spline
       used for spline interpolation. For data that is highly oscillatory
       use higher values
-    
+
     - ``point_list`` - If point_list=True is passed, then if the array
       is a list of lists of length three, it will be treated as an
       array of points rather than a 3xn array.
-    
+
     - ``num_points`` - Number of points to sample interpolating
       function in each direction, when ``interpolation_type`` is not
       ``default``. By default for an `n\times n` array this is `n`.
-    
+
     - ``**kwds`` - all other arguments are passed to the surface function
-    
+
     OUTPUT: a 3d plot
-    
+
     EXAMPLES:
 
     We plot a matrix that illustrates summation modulo `n`.
-    
+
     ::
-    
+
         sage: n = 5; list_plot3d(matrix(RDF,n,[(i+j)%n for i in [1..n] for j in [1..n]]))
-    
+
     We plot a matrix of values of sin.
-    
+
     ::
-    
+
         sage: pi = float(pi)
         sage: m = matrix(RDF, 6, [sin(i^2 + j^2) for i in [0,pi/5,..,pi] for j in [0,pi/5,..,pi]])
         sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1,1,1/3])
-    
+
     Though it doesn't change the shape of the graph, increasing
     num_points can increase the clarity of the graph.
-    
+
     ::
-    
+
         sage: list_plot3d(m, texture='yellow', frame_aspect_ratio=[1,1,1/3],num_points=40)
-    
+
     We can change the interpolation type.
-    
+
     ::
-    
+
         sage: list_plot3d(m, texture='yellow', interpolation_type='nn',frame_aspect_ratio=[1,1,1/3])
-    
+
     We can make this look better by increasing the number of samples.
-    
+
     ::
-    
+
         sage: list_plot3d(m, texture='yellow', interpolation_type='nn',frame_aspect_ratio=[1,1,1/3],num_points=40)
-    
+
     Let's try a spline.
-    
+
     ::
-    
+
         sage: list_plot3d(m, texture='yellow', interpolation_type='spline',frame_aspect_ratio=[1,1,1/3])
-    
+
     That spline doesn't capture the oscillation very well; let's try a
     higher degree spline.
-    
+
     ::
-    
+
         sage: list_plot3d(m, texture='yellow', interpolation_type='spline', degree=5, frame_aspect_ratio=[1,1,1/3])
-    
+
     We plot a list of lists::
-    
+
         sage: show(list_plot3d([[1, 1, 1, 1], [1, 2, 1, 2], [1, 1, 3, 1], [1, 2, 1, 4]]))
-    
+
     We plot a list of points.  As a first example we can extract the
     (x,y,z) coordinates from the above example and make a list plot
     out of it. By default we do linear interpolation.
-    
+
     ::
-    
+
         sage: l=[]
         sage: for i in range(6):
         ...      for j in range(6):
         ...         l.append((float(i*pi/5),float(j*pi/5),m[i,j]))
         sage: list_plot3d(l,texture='yellow')
-    
+
     Note that the points do not have to be regularly sampled. For example::
-    
+
         sage: l=[]
         sage: for i in range(-5,5):
         ...    for j in range(-5,5):
@@ -132,20 +132,20 @@
     TESTS:
 
     We plot 0, 1, and 2 points::
-    
+
         sage: list_plot3d([])
-    
+
     ::
-    
+
         sage: list_plot3d([(2,3,4)])
-    
+
     ::
-    
+
         sage: list_plot3d([(0,0,1), (2,3,4)])
 
     However, if two points are given with the same x,y coordinates but
     different z coordinates, an exception will be raised::
-    
+
         sage: pts =[(-4/5, -2/5, -2/5), (-4/5, -2/5, 2/5), (-4/5, 2/5, -2/5), (-4/5, 2/5, 2/5), (-2/5, -4/5, -2/5), (-2/5, -4/5, 2/5), (-2/5, -2/5, -4/5), (-2/5, -2/5, 4/5), (-2/5, 2/5, -4/5), (-2/5, 2/5, 4/5), (-2/5, 4/5, -2/5), (-2/5, 4/5, 2/5), (2/5, -4/5, -2/5), (2/5, -4/5, 2/5), (2/5, -2/5, -4/5), (2/5, -2/5, 4/5), (2/5, 2/5, -4/5), (2/5, 2/5, 4/5), (2/5, 4/5, -2/5), (2/5, 4/5, 2/5), (4/5, -2/5, -2/5), (4/5, -2/5, 2/5), (4/5, 2/5, -2/5), (4/5, 2/5, 2/5)]
         sage: show(list_plot3d(pts, interpolation_type='nn'))
         Traceback (most recent call last):
@@ -153,11 +153,11 @@
         ValueError: Two points with same x,y coordinates and different z coordinates were given. Interpolation cannot handle this.
 
     Additionally we need at least 3 points to do the interpolation::
-    
+
         sage: mat = matrix(RDF, 1, 2, [3.2, 1.550])
         sage: show(list_plot3d(mat,interpolation_type='nn'))
         Traceback (most recent call last):
-        ... 
+        ...
         ValueError: We need at least 3 points to perform the interpolation
     """
     import numpy
@@ -175,7 +175,7 @@
 
     if type(v)==numpy.ndarray:
         return list_plot3d(matrix(v),interpolation_type,texture,**kwds)
-        
+
     if isinstance(v, list):
         if len(v) == 0:
             # return empty 3d graphic
@@ -380,7 +380,7 @@
     #If the list of data points has two points with the exact same x,y coordinate and different z coordinates
     #then scipy sometimes segfaults. The following block checks for this. alternatively the code in the if block
     #above which adds random error could be applied to perturb the points, but probably an exception should be raised
-    #The code also removes duplicate points which scipy can't handle.    
+    #The code also removes duplicate points which scipy can't handle.
 
     drop_list=[]
 
@@ -391,7 +391,7 @@
                     raise ValueError, "Two points with same x,y coordinates and different z coordinates were given. Interpolation cannot handle this."
                 elif z[i]==z[j]:
                     drop_list.append(j)
-    
+
     x=[x[i] for i in range(len(x)) if i not in drop_list]
     y=[y[i] for i in range(len(x)) if i not in drop_list]
     z=[z[i] for i in range(len(x)) if i not in drop_list]
@@ -453,7 +453,7 @@
         if kwds.has_key('degree'):
             kx=kwds['degree']
             ky=kwds['degree']
-            
+
         s=kwds['smoothing'] if kwds.has_key('smoothing') else len(x)-numpy.sqrt(2*len(x))
         s=interpolate.bisplrep(x,y,z,[int(1)]*len(x),xmin,xmax,ymin,ymax,kx=kx,ky=ky,s=s)
         f=lambda x,y: interpolate.bisplev(x,y,s)
diff --git a/sage/plot/plot3d/parametric_plot3d.py b/sage/plot/plot3d/parametric_plot3d.py
--- a/sage/plot/plot3d/parametric_plot3d.py
+++ b/sage/plot/plot3d/parametric_plot3d.py
@@ -38,25 +38,25 @@
     INPUT:
 
     - ``f`` - a 3-tuple of functions or expressions, or vector of size 3
-    
+
     - ``urange`` - a 2-tuple (u_min, u_max) or a 3-tuple
       (u, u_min, u_max)
-    
+
     - ``vrange`` - (optional - only used for surfaces) a
       2-tuple (v_min, v_max) or a 3-tuple (v, v_min, v_max)
-    
+
     - ``plot_points`` - (default: "automatic", which is
       75 for curves and [40,40] for surfaces) initial number of sample
       points in each parameter; an integer for a curve, and a pair of
       integers for a surface.
-    
+
     - ``boundary_style`` - (default: None, no boundary) a dict that describes
       how to draw the boundaries of regions by giving options that are passed
       to the line3d command.
-    
+
     - ``mesh`` - bool (default: False) whether to display
       mesh grid lines
-    
+
     - ``dots`` - bool (default: False) whether to display
       dots at mesh grid points
 
@@ -71,82 +71,82 @@
 
        #. mesh and dots are not supported when using the Tachyon ray tracer
           renderer.
-    
-    
+
+
     EXAMPLES: We demonstrate each of the four ways to call this
     function.
-    
-    
+
+
     #. A space curve defined by three functions of 1 variable:
-    
+
        ::
-    
+
            sage: parametric_plot3d( (sin, cos, lambda u: u/10), (0, 20))
-    
+
        Note above the lambda function, which creates a callable Python
        function that sends `u` to `u/10`.
-    
+
     #. Next we draw the same plot as above, but using symbolic
        functions:
-    
+
        ::
-    
+
            sage: u = var('u')
            sage: parametric_plot3d( (sin(u), cos(u), u/10), (u, 0, 20))
-    
+
     #. We draw a parametric surface using 3 Python functions (defined
        using lambda):
-    
+
        ::
-    
+
            sage: f = (lambda u,v: cos(u), lambda u,v: sin(u)+cos(v), lambda u,v: sin(v))
            sage: parametric_plot3d(f, (0, 2*pi), (-pi, pi))
-    
+
     #. The surface, but with a mesh:
-    
+
        ::
-    
+
            sage: u, v = var('u,v')
-           sage: parametric_plot3d((cos(u), sin(u) + cos(v), sin(v)), (u, 0, 2*pi), (v, -pi, pi), mesh=True)        
-    
+           sage: parametric_plot3d((cos(u), sin(u) + cos(v), sin(v)), (u, 0, 2*pi), (v, -pi, pi), mesh=True)
+
     #. The same surface, but where the defining functions are
        symbolic:
-    
+
        ::
-    
+
            sage: u, v = var('u,v')
            sage: parametric_plot3d((cos(u), sin(u) + cos(v), sin(v)), (u, 0, 2*pi), (v, -pi, pi))
-    
+
        We increase the number of plot points, and make the surface green
        and transparent:
-    
+
        ::
-    
+
            sage: parametric_plot3d((cos(u), sin(u) + cos(v), sin(v)), (u, 0, 2*pi), (v, -pi, pi), color='green', opacity=0.1, plot_points=[30,30])
-    
-    
+
+
     We call the space curve function but with polynomials instead of
     symbolic variables.
-    
+
     ::
-    
+
         sage: R.<t> = RDF[]
-        sage: parametric_plot3d( (t, t^2, t^3), (t, 0, 3) ) 
-    
+        sage: parametric_plot3d( (t, t^2, t^3), (t, 0, 3) )
+
     Next we plot the same curve, but because we use (0, 3) instead of
     (t, 0, 3), each polynomial is viewed as a callable function of one
     variable::
-    
-        sage: parametric_plot3d( (t, t^2, t^3), (0, 3) ) 
-    
+
+        sage: parametric_plot3d( (t, t^2, t^3), (0, 3) )
+
     We do a plot but mix a symbolic input, and an integer::
-    
+
         sage: t = var('t')
-        sage: parametric_plot3d( (1, sin(t), cos(t)), (t, 0, 3) ) 
+        sage: parametric_plot3d( (1, sin(t), cos(t)), (t, 0, 3) )
 
     We specify a boundary style to show us the values of the function at its
     extrema::
-        
+
         sage: u, v = var('u,v')
         sage: parametric_plot3d((cos(u), sin(u) + cos(v), sin(v)), (u, 0, pi), (v, 0, pi), \
         ...                     boundary_style={"color": "black", "thickness": 2})
@@ -163,302 +163,302 @@
 
     Any options you would normally use to specify the appearance of a curve are
     valid as entries in the boundary_style dict.
-    
+
     MANY MORE EXAMPLES:
-    
+
     We plot two interlinked tori::
-    
+
         sage: u, v = var('u,v')
         sage: f1 = (4+(3+cos(v))*sin(u), 4+(3+cos(v))*cos(u), 4+sin(v))
         sage: f2 = (8+(3+cos(v))*cos(u), 3+sin(v), 4+(3+cos(v))*sin(u))
         sage: p1 = parametric_plot3d(f1, (u,0,2*pi), (v,0,2*pi), texture="red")
         sage: p2 = parametric_plot3d(f2, (u,0,2*pi), (v,0,2*pi), texture="blue")
         sage: p1 + p2
-    
+
     A cylindrical Star of David::
-    
+
         sage: u,v = var('u v')
         sage: f_x = cos(u)*cos(v)*(abs(cos(3*v/4))^500 + abs(sin(3*v/4))^500)^(-1/260)*(abs(cos(4*u/4))^200 + abs(sin(4*u/4))^200)^(-1/200)
         sage: f_y = cos(u)*sin(v)*(abs(cos(3*v/4))^500 + abs(sin(3*v/4))^500)^(-1/260)*(abs(cos(4*u/4))^200 + abs(sin(4*u/4))^200)^(-1/200)
         sage: f_z = sin(u)*(abs(cos(4*u/4))^200 + abs(sin(4*u/4))^200)^(-1/200)
         sage: parametric_plot3d([f_x, f_y, f_z], (u, -pi, pi), (v, 0, 2*pi))
-    
+
     Double heart::
-    
+
         sage: u, v = var('u,v')
         sage: f_x = ( abs(v) - abs(u) - abs(tanh((1/sqrt(2))*u)/(1/sqrt(2))) + abs(tanh((1/sqrt(2))*v)/(1/sqrt(2))) )*sin(v)
         sage: f_y = ( abs(v) - abs(u) - abs(tanh((1/sqrt(2))*u)/(1/sqrt(2))) - abs(tanh((1/sqrt(2))*v)/(1/sqrt(2))) )*cos(v)
         sage: f_z = sin(u)*(abs(cos(4*u/4))^1 + abs(sin(4*u/4))^1)^(-1/1)
         sage: parametric_plot3d([f_x, f_y, f_z], (u, 0, pi), (v, -pi, pi))
-    
+
     Heart::
-    
+
         sage: u, v = var('u,v')
         sage: f_x = cos(u)*(4*sqrt(1-v^2)*sin(abs(u))^abs(u))
         sage: f_y = sin(u) *(4*sqrt(1-v^2)*sin(abs(u))^abs(u))
         sage: f_z = v
         sage: parametric_plot3d([f_x, f_y, f_z], (u, -pi, pi), (v, -1, 1), frame=False, color="red")
-    
+
     Green bowtie::
-    
+
         sage: u, v = var('u,v')
         sage: f_x = sin(u) / (sqrt(2) + sin(v))
         sage: f_y = sin(u) / (sqrt(2) + cos(v))
         sage: f_z = cos(u) / (1 + sqrt(2))
         sage: parametric_plot3d([f_x, f_y, f_z], (u, -pi, pi), (v, -pi, pi), frame=False, color="green")
-    
+
     Boy's surface http://en.wikipedia.org/wiki/Boy's_surface
-    
+
     ::
-    
+
         sage: u, v = var('u,v')
         sage: fx = 2/3* (cos(u)* cos(2*v) + sqrt(2)* sin(u)* cos(v))* cos(u) / (sqrt(2) - sin(2*u)* sin(3*v))
         sage: fy = 2/3* (cos(u)* sin(2*v) - sqrt(2)* sin(u)* sin(v))* cos(u) / (sqrt(2) - sin(2*u)* sin(3*v))
         sage: fz = sqrt(2)* cos(u)* cos(u) / (sqrt(2) - sin(2*u)* sin(3*v))
         sage: parametric_plot3d([fx, fy, fz], (u, -2*pi, 2*pi), (v, 0, pi), plot_points = [90,90], frame=False, color="orange") # long time -- about 30 seconds
-    
+
     Maeder's_Owl (pretty but can't find an internet reference)::
-    
+
         sage: u, v = var('u,v')
         sage: fx = v *cos(u) - 0.5* v^2 * cos(2* u)
         sage: fy = -v *sin(u) - 0.5* v^2 * sin(2* u)
         sage: fz = 4 *v^1.5 * cos(3 *u / 2) / 3
         sage: parametric_plot3d([fx, fy, fz], (u, -2*pi, 2*pi), (v, 0, 1),plot_points = [90,90], frame=False, color="purple")
-    
+
     Bracelet::
-    
+
         sage: u, v = var('u,v')
         sage: fx = (2 + 0.2*sin(2*pi*u))*sin(pi*v)
         sage: fy = 0.2*cos(2*pi*u) *3*cos(2*pi*v)
         sage: fz = (2 + 0.2*sin(2*pi*u))*cos(pi*v)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, pi/2), (v, 0, 3*pi/4), frame=False, color="gray")
-    
+
     Green goblet
-    
+
     ::
-    
+
         sage: u, v = var('u,v')
         sage: fx = cos(u)*cos(2*v)
         sage: fy = sin(u)*cos(2*v)
         sage: fz = sin(v)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0, pi), frame=False, color="green")
-    
+
     Funny folded surface - with square projection::
-    
+
         sage: u, v = var('u,v')
         sage: fx = cos(u)*sin(2*v)
         sage: fy = sin(u)*cos(2*v)
         sage: fz = sin(v)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0, 2*pi), frame=False, color="green")
-    
+
     Surface of revolution of figure 8::
-    
+
         sage: u, v = var('u,v')
         sage: fx = cos(u)*sin(2*v)
         sage: fy = sin(u)*sin(2*v)
         sage: fz = sin(v)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0, 2*pi), frame=False, color="green")
-    
+
     Yellow Whitney's umbrella
     http://en.wikipedia.org/wiki/Whitney_umbrella::
-    
+
         sage: u, v = var('u,v')
         sage: fx = u*v
         sage: fy = u
         sage: fz = v^2
         sage: parametric_plot3d([fx, fy, fz], (u, -1, 1), (v, -1, 1), frame=False, color="yellow")
-    
+
     Cross cap http://en.wikipedia.org/wiki/Cross-cap::
-    
+
         sage: u, v = var('u,v')
         sage: fx = (1+cos(v))*cos(u)
         sage: fy = (1+cos(v))*sin(u)
         sage: fz = -tanh((2/3)*(u-pi))*sin(v)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0, 2*pi), frame=False, color="red")
-    
+
     Twisted torus::
-    
+
         sage: u, v = var('u,v')
         sage: fx = (3+sin(v)+cos(u))*cos(2*v)
         sage: fy = (3+sin(v)+cos(u))*sin(2*v)
         sage: fz = sin(u)+2*cos(v)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0, 2*pi), frame=False, color="red")
-    
+
     Four intersecting discs::
-    
+
         sage: u, v = var('u,v')
         sage: fx = v *cos(u) -0.5*v^2*cos(2*u)
         sage: fy = -v*sin(u) -0.5*v^2*sin(2*u)
         sage: fz = 4* v^1.5 *cos(3* u / 2) / 3
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 4*pi), (v, 0,2*pi), frame=False, color="red", opacity=0.7)
-    
+
     Steiner surface/Roman's surface (see
     http://en.wikipedia.org/wiki/Roman_surface and
     http://en.wikipedia.org/wiki/Steiner_surface)::
-    
+
         sage: u, v = var('u,v')
         sage: fx = (sin(2 * u) * cos(v) * cos(v))
         sage: fy = (sin(u) * sin(2 * v))
         sage: fz = (cos(u) * sin(2 * v))
         sage: parametric_plot3d([fx, fy, fz], (u, -pi/2, pi/2), (v, -pi/2,pi/2), frame=False, color="red")
-    
+
     Klein bottle? (see http://en.wikipedia.org/wiki/Klein_bottle)::
-    
+
         sage: u, v = var('u,v')
         sage: fx = (3*(1+sin(v)) + 2*(1-cos(v)/2)*cos(u))*cos(v)
         sage: fy = (4+2*(1-cos(v)/2)*cos(u))*sin(v)
         sage: fz = -2*(1-cos(v)/2) * sin(u)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0, 2*pi), frame=False, color="green")
-    
+
     A Figure 8 embedding of the Klein bottle (see
     http://en.wikipedia.org/wiki/Klein_bottle)::
-    
+
         sage: u, v = var('u,v')
         sage: fx = (2 + cos(v/2)* sin(u) - sin(v/2)* sin(2 *u))* cos(v)
         sage: fy = (2 + cos(v/2)* sin(u) - sin(v/2)* sin(2 *u))* sin(v)
         sage: fz = sin(v/2)* sin(u) + cos(v/2) *sin(2* u)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0, 2*pi), frame=False, color="red")
-    
+
     Enneper's surface (see
     http://en.wikipedia.org/wiki/Enneper_surface)::
-    
+
         sage: u, v = var('u,v')
         sage: fx = u -u^3/3  + u*v^2
         sage: fy = v -v^3/3  + v*u^2
         sage: fz = u^2 - v^2
         sage: parametric_plot3d([fx, fy, fz], (u, -2, 2), (v, -2, 2), frame=False, color="red")
-    
+
     Henneberg's surface (see
     http://xahlee.org/surface/gallery_m.html)
-    
+
     ::
-    
+
         sage: u, v = var('u,v')
         sage: fx = 2*sinh(u)*cos(v) -(2/3)*sinh(3*u)*cos(3*v)
         sage: fy = 2*sinh(u)*sin(v) +(2/3)*sinh(3*u)*sin(3*v)
         sage: fz = 2*cosh(2*u)*cos(2*v)
         sage: parametric_plot3d([fx, fy, fz], (u, -1, 1), (v, -pi/2, pi/2), frame=False, color="red")
-    
+
     Dini's spiral
-    
+
     ::
-    
+
         sage: u, v = var('u,v')
         sage: fx = cos(u)*sin(v)
         sage: fy = sin(u)*sin(v)
         sage: fz = (cos(v)+log(tan(v/2))) + 0.2*u
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 12.4), (v, 0.1, 2),frame=False, color="red")
-    
+
     Catalan's surface (see
     http://xahlee.org/surface/catalan/catalan.html)::
-    
+
         sage: u, v = var('u,v')
         sage: fx = u-sin(u)*cosh(v)
         sage: fy = 1-cos(u)*cosh(v)
         sage: fz = 4*sin(1/2*u)*sinh(v/2)
-        sage: parametric_plot3d([fx, fy, fz], (u, -pi, 3*pi), (v, -2, 2), frame=False, color="red")        
-    
+        sage: parametric_plot3d([fx, fy, fz], (u, -pi, 3*pi), (v, -2, 2), frame=False, color="red")
+
     A Conchoid::
-    
+
         sage: u, v = var('u,v')
         sage: k = 1.2; k_2 = 1.2; a = 1.5
         sage: f = (k^u*(1+cos(v))*cos(u), k^u*(1+cos(v))*sin(u), k^u*sin(v)-a*k_2^u)
         sage: parametric_plot3d(f, (u,0,6*pi), (v,0,2*pi), plot_points=[40,40], texture=(0,0.5,0))
-    
+
     A Mobius strip::
-    
+
         sage: u,v = var("u,v")
         sage: parametric_plot3d([cos(u)*(1+v*cos(u/2)), sin(u)*(1+v*cos(u/2)), 0.2*v*sin(u/2)], (u,0, 4*pi+0.5), (v,0, 0.3),plot_points=[50,50])
-    
+
     A Twisted Ribbon
-    
+
     ::
-    
+
         sage: u, v = var('u,v')
         sage: parametric_plot3d([3*sin(u)*cos(v), 3*sin(u)*sin(v), cos(v)], (u,0, 2*pi), (v, 0, pi),plot_points=[50,50])
-    
+
     An Ellipsoid::
-    
+
         sage: u, v = var('u,v')
         sage: parametric_plot3d([3*sin(u)*cos(v), 2*sin(u)*sin(v), cos(u)], (u,0, 2*pi), (v, 0, 2*pi),plot_points=[50,50], aspect_ratio=[1,1,1])
-    
+
     A Cone::
-    
+
         sage: u, v = var('u,v')
         sage: parametric_plot3d([u*cos(v), u*sin(v), u], (u, -1, 1), (v, 0, 2*pi+0.5), plot_points=[50,50])
-    
+
     A Paraboloid::
-    
+
         sage: u, v = var('u,v')
         sage: parametric_plot3d([u*cos(v), u*sin(v), u^2], (u, 0, 1), (v, 0, 2*pi+0.4), plot_points=[50,50])
-    
+
     A Hyperboloid::
-    
+
         sage: u, v = var('u,v')
         sage: plot3d(u^2-v^2, (u, -1, 1), (v, -1, 1), plot_points=[50,50])
-    
+
     A weird looking surface - like a Mobius band but also an O::
-    
+
         sage: u, v = var('u,v')
         sage: parametric_plot3d([sin(u)*cos(u)*log(u^2)*sin(v), (u^2)^(1/6)*(cos(u)^2)^(1/4)*cos(v), sin(v)], (u, 0.001, 1), (v, -pi, pi+0.2), plot_points=[50,50])
-    
+
     A heart, but not a cardioid (for my wife)::
-    
+
         sage: u, v = var('u,v')
         sage: p1 = parametric_plot3d([sin(u)*cos(u)*log(u^2)*v*(1-v)/2, ((u^6)^(1/20)*(cos(u)^2)^(1/4)-1/2)*v*(1-v), v^(0.5)], (u, 0.001, 1), (v, 0, 1), plot_points=[70,70], color='red')
         sage: p2 = parametric_plot3d([-sin(u)*cos(u)*log(u^2)*v*(1-v)/2, ((u^6)^(1/20)*(cos(u)^2)^(1/4)-1/2)*v*(1-v), v^(0.5)], (u, 0.001, 1), (v, 0, 1), plot_points=[70,70], color='red')
         sage: show(p1+p2, frame=False)
-    
+
     A Hyperhelicoidal::
-    
+
         sage: u = var("u")
         sage: v = var("v")
         sage: fx = (sinh(v)*cos(3*u))/(1+cosh(u)*cosh(v))
         sage: fy = (sinh(v)*sin(3*u))/(1+cosh(u)*cosh(v))
         sage: fz = (cosh(v)*sinh(u))/(1+cosh(u)*cosh(v))
         sage: parametric_plot3d([fx, fy, fz], (u, -pi, pi), (v, -pi, pi), plot_points = [50,50], frame=False, color="red")
-    
+
     A Helicoid (lines through a helix,
     http://en.wikipedia.org/wiki/Helix)::
-    
+
         sage: u, v = var('u,v')
         sage: fx = sinh(v)*sin(u)
         sage: fy = -sinh(v)*cos(u)
         sage: fz = 3*u
         sage: parametric_plot3d([fx, fy, fz], (u, -pi, pi), (v, -pi, pi), plot_points = [50,50], frame=False, color="red")
-    
+
     Kuen's surface
     (http://www.math.umd.edu/research/bianchi/Gifccsurfs/ccsurfs.html)::
-    
+
         sage: fx = (2*(cos(u) + u*sin(u))*sin(v))/(1+ u^2*sin(v)^2)
         sage: fy = (2*(sin(u) - u*cos(u))*sin(v))/(1+ u^2*sin(v)^2)
         sage: fz = log(tan(1/2 *v)) + (2*cos(v))/(1+ u^2*sin(v)^2)
         sage: parametric_plot3d([fx, fy, fz], (u, 0, 2*pi), (v, 0.01, pi-0.01), plot_points = [50,50], frame=False, color="green")
-    
+
     A 5-pointed star::
-    
+
         sage: fx = cos(u)*cos(v)*(abs(cos(1*u/4))^0.5 + abs(sin(1*u/4))^0.5)^(-1/0.3)*(abs(cos(5*v/4))^1.7 + abs(sin(5*v/4))^1.7)^(-1/0.1)
         sage: fy = cos(u)*sin(v)*(abs(cos(1*u/4))^0.5 + abs(sin(1*u/4))^0.5)^(-1/0.3)*(abs(cos(5*v/4))^1.7 + abs(sin(5*v/4))^1.7)^(-1/0.1)
         sage: fz = sin(u)*(abs(cos(1*u/4))^0.5 + abs(sin(1*u/4))^0.5)^(-1/0.3)
         sage: parametric_plot3d([fx, fy, fz], (u, -pi/2, pi/2), (v, 0, 2*pi), plot_points = [50,50], frame=False, color="green")
-    
+
     A cool self-intersecting surface (Eppener surface?)::
-    
+
         sage: fx = u - u^3/3 + u*v^2
         sage: fy = v - v^3/3 + v*u^2
         sage: fz = u^2 - v^2
         sage: parametric_plot3d([fx, fy, fz], (u, -25, 25), (v, -25, 25), plot_points = [50,50], frame=False, color="green")
-    
+
     The breather surface
     (http://en.wikipedia.org/wiki/Breather_surface)::
-    
+
         sage: fx = (2*sqrt(0.84)*cosh(0.4*u)*(-(sqrt(0.84)*cos(v)*cos(sqrt(0.84)*v)) - sin(v)*sin(sqrt(0.84)*v)))/(0.4*((sqrt(0.84)*cosh(0.4*u))^2 + (0.4*sin(sqrt(0.84)*v))^2))
         sage: fy = (2*sqrt(0.84)*cosh(0.4*u)*(-(sqrt(0.84)*sin(v)*cos(sqrt(0.84)*v)) + cos(v)*sin(sqrt(0.84)*v)))/(0.4*((sqrt(0.84)*cosh(0.4*u))^2 + (0.4*sin(sqrt(0.84)*v))^2))
         sage: fz = -u + (2*0.84*cosh(0.4*u)*sinh(0.4*u))/(0.4*((sqrt(0.84)*cosh(0.4*u))^2 + (0.4*sin(sqrt(0.84)*v))^2))
         sage: parametric_plot3d([fx, fy, fz], (u, -13.2, 13.2), (v, -37.4, 37.4), plot_points = [90,90], frame=False, color="green")
-    
+
     TESTS::
-    
+
         sage: u, v = var('u,v')
         sage: plot3d(u^2-v^2, (u, -1, 1), (u, -1, 1))
         Traceback (most recent call last):
@@ -467,7 +467,7 @@
 
 
     From Trac #2858::
-    
+
         sage: parametric_plot3d((u,-u,v), (u,-10,10),(v,-10,10))
         sage: f(u)=u; g(v)=v^2; parametric_plot3d((g,f,f), (-10,10),(-10,10))
 
@@ -481,7 +481,7 @@
     #   * Surface -- behavior of functions not defined everywhere -- see note above
     #   * Iterative refinement
 
-    
+
     # color_function -- (default: "automatic") how to determine the color of curves and surfaces
     # color_function_scaling -- (default: True) whether to scale the input to color_function
     # exclusions -- (default: "automatic") u points or (u,v) conditions to exclude.
@@ -499,7 +499,7 @@
 
     if isinstance(f, (list,tuple)) and len(f) > 0 and isinstance(f[0], (list,tuple)):
         return sum([parametric_plot3d(v, urange, vrange, plot_points=plot_points, **kwds) for v in f])
-            
+
     if not isinstance(f, (tuple, list)) or len(f) != 3:
         raise ValueError, "f must be a list, tuple, or vector of length 3"
 
@@ -513,7 +513,7 @@
         G = _parametric_plot3d_surface(f, urange, vrange, plot_points=plot_points, boundary_style=boundary_style, **kwds)
     G._set_extra_kwds(kwds)
     return G
-    
+
 def _parametric_plot3d_curve(f, urange, plot_points, **kwds):
     r"""
     Return a parametric three-dimensional space curve.
@@ -620,7 +620,7 @@
     urange = srange(*ranges[0], include_endpoint=True)
     vrange = srange(*ranges[1], include_endpoint=True)
     G = ParametricSurface(g, (urange, vrange), **kwds)
-    
+
     if boundary_style is not None:
         for u in (urange[0], urange[-1]):
             G += line3d([(g[0](u,v), g[1](u,v), g[2](u,v)) for v in vrange], **boundary_style)
diff --git a/sage/plot/plot3d/platonic.py b/sage/plot/plot3d/platonic.py
--- a/sage/plot/plot3d/platonic.py
+++ b/sage/plot/plot3d/platonic.py
@@ -56,20 +56,20 @@
 
 def index_face_set(face_list, point_list, enclosed, **kwds):
     """
-    Helper function that creates ``IndexFaceSet`` object for the 
+    Helper function that creates ``IndexFaceSet`` object for the
     tetrahedron, dodecahedron, and icosahedron.
-    
+
     INPUT:
-    
-    -  ``face_list`` - list of faces, given explicitly from the 
+
+    -  ``face_list`` - list of faces, given explicitly from the
        solid invocation
-    
+
     -  ``point_list`` - list of points, given explicitly from the
        solid invocation
-    
+
     -  ``enclosed`` - boolean (default passed is always True
        for these solids)
-    
+
     TESTS:
 
     Verify that these are working and passing on keywords::
@@ -101,18 +101,18 @@
     """
     Helper function that scales and translates the platonic
     solid, and passes extra keywords on.
-    
+
     INPUT:
-    
+
     -  ``center`` - 3-tuple indicating the center (default passed
        from :func:`index_face_set` is the origin `(0,0,0)`)
-    
+
     -  ``size`` - number indicating amount to scale by (default
        passed from :func:`index_face_set` is 1)
-    
+
     -  ``kwds`` - a dictionary of keywords, passed from solid
        invocation by :func:`index_face_set`
-    
+
     TESTS:
 
     Verify that scaling and moving the center work together properly,
@@ -130,50 +130,50 @@
 def tetrahedron(center=(0,0,0), size=1, **kwds):
     """
     A 3d tetrahedron.
-    
+
     INPUT:
-    
-    
+
+
     -  ``center`` - (default: (0,0,0))
-    
+
     -  ``size`` - (default: 1)
-    
+
     -  ``color`` - a word that describes a color
-    
+
     -  ``rgbcolor`` - (r,g,b) with r, g, b between 0 and 1
        that describes a color
-    
+
     -  ``opacity`` - (default: 1) if less than 1 then is
        transparent
-    
-    
+
+
     EXAMPLES: A default colored tetrahedron at the origin::
-    
+
         sage: tetrahedron()
-    
+
     A transparent green tetrahedron in front of a solid red one::
-    
+
         sage: tetrahedron(opacity=0.8, color='green') + tetrahedron((-2,1,0),color='red')
-    
+
     A translucent tetrahedron sharing space with a sphere::
-    
+
         sage: tetrahedron(color='yellow',opacity=0.7) + sphere(r=.5, color='red')
-    
+
     A big tetrahedron::
-    
+
         sage: tetrahedron(size=10)
-    
+
     A wide tetrahedron::
-    
+
         sage: tetrahedron(aspect_ratio=[1,1,1]).scale((4,4,1))
-    
+
     A red and blue tetrahedron touching noses::
-    
+
         sage: tetrahedron(color='red') + tetrahedron((0,0,-2)).scale([1,1,-1])
-    
+
     A Dodecahedral complex of 5 tetrahedrons (a more elaborate examples
     from Peter Jipsen)::
-    
+
         sage: v=(sqrt(5.)/2-5/6, 5/6*sqrt(3.)-sqrt(15.)/2, sqrt(5.)/3)
         sage: t=acos(sqrt(5.)/3)/2
         sage: t1=tetrahedron(aspect_ratio=(1,1,1), opacity=0.5).rotateZ(t)
@@ -182,7 +182,7 @@
         sage: t4=tetrahedron(color='yellow', opacity=0.5).rotateZ(t).rotate(v,6*pi/5)
         sage: t5=tetrahedron(color='orange', opacity=0.5).rotateZ(t).rotate(v,8*pi/5)
         sage: show(t1+t2+t3+t4+t5, frame=False, zoom=1.3)
-    
+
     AUTHORS:
 
     - Robert Bradshaw and William Stein
@@ -203,77 +203,77 @@
 def cube(center=(0,0,0), size=1, color=None, frame_thickness=0, frame_color=None, **kwds):
     """
     A 3D cube centered at the origin with default side lengths 1.
-    
+
     INPUT:
-    
-    
+
+
     -  ``center`` - (default: (0,0,0))
-    
+
     -  ``size`` - (default: 1) the side lengths of the
        cube
-    
+
     -  ``color`` - a string that describes a color; this
        can also be a list of 3-tuples or strings length 6 or 3, in which
        case the faces (and oppositive faces) are colored.
-    
+
     -  ``frame_thickness`` - (default: 0) if positive,
        then thickness of the frame
-    
+
     -  ``frame_color`` - (default: None) if given, gives
        the color of the frame
-    
+
     -  ``opacity`` - (default: 1) if less than 1 then it's
        transparent
-    
-    
+
+
     EXAMPLES:
 
     A simple cube::
-    
+
         sage: cube()
-    
+
     A red cube::
-    
+
         sage: cube(color="red")
-    
+
     A transparent grey cube that contains a red cube::
-    
+
         sage: cube(opacity=0.8, color='grey') + cube(size=3/4)
-    
+
     A transparent colored cube::
-    
+
         sage: cube(color=['red', 'green', 'blue'], opacity=0.5)
-    
+
     A bunch of random cubes::
-    
+
         sage: v = [(random(), random(), random()) for _ in [1..30]]
         sage: sum([cube((10*a,10*b,10*c), size=random()/3, color=(a,b,c)) for a,b,c in v])
-    
+
     Non-square cubes (boxes)::
-    
+
         sage: cube(aspect_ratio=[1,1,1]).scale([1,2,3])
         sage: cube(color=['red', 'blue', 'green'],aspect_ratio=[1,1,1]).scale([1,2,3])
-    
+
     And one that is colored::
-    
+
         sage: cube(color=['red', 'blue', 'green', 'black', 'white', 'orange'], \
                   aspect_ratio=[1,1,1]).scale([1,2,3])
-    
+
     A nice translucent color cube with a frame::
-    
+
         sage: c = cube(color=['red', 'blue', 'green'], frame=False, frame_thickness=2, \
                        frame_color='brown', opacity=0.8)
         sage: c
-    
+
     A raytraced color cube with frame and transparency::
-    
+
         sage: c.show(viewer='tachyon')
-    
+
     This shows #11272 has been fixed::
-    
+
         sage: cube(center=(10, 10, 10), size=0.5).bounding_box()
         ((9.75, 9.75, 9.75), (10.25, 10.25, 10.25))
-    
+
     AUTHORS:
 
     - William Stein
@@ -294,24 +294,24 @@
 def octahedron(center=(0,0,0), size=1, **kwds):
     r"""
     Return an octahedron.
-    
+
     INPUT:
-    
-    
+
+
     -  ``center`` - (default: (0,0,0))
-    
+
     -  ``size`` - (default: 1)
-    
+
     -  ``color`` - a string that describes a color; this
        can also be a list of 3-tuples or strings length 6 or 3, in which
        case the faces (and oppositive faces) are colored.
-    
+
     -  ``opacity`` - (default: 1) if less than 1 then is
        transparent
-    
-    
+
+
     EXAMPLES::
-    
+
         sage: octahedron((1,4,3), color='orange') + \
                      octahedron((0,2,1), size=2, opacity=0.6)
     """
@@ -322,49 +322,49 @@
 def dodecahedron(center=(0,0,0), size=1, **kwds):
     r"""
     A dodecahedron.
-    
+
     INPUT:
-    
-    
+
+
     -  ``center`` - (default: (0,0,0))
-    
+
     -  ``size`` - (default: 1)
-    
+
     -  ``color`` - a string that describes a color; this
        can also be a list of 3-tuples or strings length 6 or 3, in which
        case the faces (and oppositive faces) are colored.
-    
+
     -  ``opacity`` - (default: 1) if less than 1 then is
        transparent
-    
-    
+
+
     EXAMPLES: A plain Dodecahedron::
-    
+
         sage: dodecahedron()
-    
+
     A translucent dodecahedron that contains a black sphere::
-    
+
         sage: dodecahedron(color='orange', opacity=0.8) + \
               sphere(size=0.5, color='black')
-    
+
     CONSTRUCTION: This is how we construct a dodecahedron. We let one
     point be `Q = (0,1,0)`.
-    
+
     Now there are three points spaced equally on a circle around the
     north pole. The other requirement is that the angle between them be
     the angle of a pentagon, namely `3\pi/5`. This is enough to
     determine them. Placing one on the `xz`-plane we have.
-    
+
     `P_1 = \left(t, 0, \sqrt{1-t^2}\right)`
-    
+
     `P_2 = \left(-\frac{1}{2}t, \frac{\sqrt{3}}{2}t, \sqrt{1-t^2}\right)`
-    
+
     `P_3 = \left(-\frac{1}{2}t, \frac{\sqrt{3}}{2}t, \sqrt{1-t^2}\right)`
-    
+
     Solving
     `\frac{(P_1-Q) \cdot (P_2-Q)}{|P_1-Q||P_2-Q|} = \cos(3\pi/5)`
     we get `t = 2/3`.
-    
+
     Now we have 6 points `R_1, ..., R_6` to close the three
     top pentagons. These can be found by mirroring `P_2` and
     `P_3` by the `yz`-plane and rotating around the
@@ -372,9 +372,9 @@
     `P_1`. Note that `\cos(\theta) = t = 2/3` and so
     `\sin(\theta) = \sqrt{5}/3`. Rotation gives us the other
     four.
-    
+
     Now we reflect through the origin for the bottom half.
-    
+
     AUTHORS:
 
     - Robert Bradshaw, William Stein
@@ -396,10 +396,10 @@
     # The second ring
     R1 = R3([sqrt5/3,  1/sqrt3, one/3])
     R2 = R3([sqrt5/3, -1/sqrt3, one/3])
-    
+
     top = [Q, P1, rot*P1, rot2*P1, R1, rot*R2, rot*R1, rot2*R2, rot2*R1, R2]
     point_list = top + [-p for p in reversed(top)]
-    
+
     top_faces = [[0,1,4,5,2],
                  [0,2,6,7,3],
                  [0,3,8,9,1],
@@ -407,7 +407,7 @@
                  [2,5,11,10,6],
                  [3,7,15,14,8]]
     face_list = top_faces + [[19-p for p in reversed(f)] for f in top_faces]
-    
+
     if 'aspect_ratio' not in kwds:
         kwds['aspect_ratio'] = [1,1,1]
     return index_face_set(face_list, point_list, enclosed=True, center=center, size=size, **kwds)
@@ -420,35 +420,35 @@
 #        faces = IndexFaceSet([[tuple(vs[i]) for i in f] for f in face_list])
 #        vertex_spheres += [faces.stickers(['red','yellow','blue','purple','black','orange'], .1, .1)] # [faces]
 #        return Graphics3dGroup(vertex_spheres)
-    
-        
+
+
 def icosahedron(center=(0,0,0), size=1, **kwds):
     r"""
     An icosahedron.
-    
+
     INPUT:
-    
-    
+
+
     -  ``center`` - (default: (0,0,0))
-    
+
     -  ``size`` - (default: 1)
-    
+
     -  ``color`` - a string that describes a color; this
        can also be a list of 3-tuples or strings length 6 or 3, in which
        case the faces (and oppositive faces) are colored.
-    
+
     -  ``opacity`` - (default: 1) if less than 1 then is
        transparent
-    
-    
+
+
     EXAMPLES::
-    
+
         sage: icosahedron()
-    
+
     Two icosahedrons at different positions of different sizes.
-    
+
     ::
-    
+
         sage: icosahedron((-1/2,0,1), color='orange') + \
               icosahedron((2,0,1), size=1/2, aspect_ratio=[1,1,1])
     """
diff --git a/sage/plot/plot3d/plot3d.py b/sage/plot/plot3d/plot3d.py
--- a/sage/plot/plot3d/plot3d.py
+++ b/sage/plot/plot3d/plot3d.py
@@ -51,7 +51,7 @@
 - Oscar Lazo, William Cauchois, Jason Grout (2009-2010): Adding coordinate transformations
 """
 
-    
+
 #TODO:
 #    -- smooth triangles
 
@@ -125,7 +125,7 @@
         subclass to set a different name.
 
         TESTS::
-        
+
             sage: from sage.plot.plot3d.plot3d import _ArbitraryCoordinates as arb
             sage: x,y,z=var('x,y,z')
             sage: c=arb((x+z,y*z,z), z, (x,y))
@@ -138,7 +138,7 @@
         """
         Return the transformation for this coordinate system in terms of the
         specified variables (which should be keywords).
-        
+
         TESTS::
 
             sage: from sage.plot.plot3d.plot3d import _ArbitraryCoordinates as arb
@@ -172,7 +172,7 @@
             (x + y, x - y, 2*x + y)
             sage: [h(1,2) for h in T.to_cartesian(lambda x,y: 2*x+y)]
             [3, -1, 4]
-            
+
         We try to return a function having the same variable names as
         the function passed in::
 
@@ -241,14 +241,14 @@
                 else:
                     raise ValueError, "function is not callable"
             def subs_func(t):
-                # We use eval so that the lambda function has the same 
+                # We use eval so that the lambda function has the same
                 # variable names as the original function
                 ll="""lambda {x},{y}: t.subs({{
                     dep_var_dummy: func({x}, {y}),
                     indep_var_dummies[0]: {x},
                     indep_var_dummies[1]: {y}
                 }})""".format(x=params[0], y=params[1])
-                return eval(ll,dict(t=t, func=func, dep_var_dummy=dep_var_dummy, 
+                return eval(ll,dict(t=t, func=func, dep_var_dummy=dep_var_dummy,
                                     indep_var_dummies=indep_var_dummies))
             return map(subs_func, transformation)
 
@@ -257,7 +257,7 @@
         Print out a coordinate system
 
         ::
-        
+
             sage: from sage.plot.plot3d.plot3d import _ArbitraryCoordinates as arb
             sage: x,y,z=var('x,y,z')
             sage: c=arb((x+z,y*z,z), z, (x,y))
@@ -278,9 +278,9 @@
     Find the names of arguments (that do not have default values) for
     a callable function, taking care of several special cases in Sage.
     If the parameters cannot be found, then return None.
-    
+
     EXAMPLES::
-    
+
         sage: from sage.plot.plot3d.plot3d import _find_arguments_for_callable
         sage: _find_arguments_for_callable(lambda x,y: x+y)
         ['x', 'y']
@@ -338,7 +338,7 @@
            functions.
 
          - ``dep_var`` - The dependent (function) variable.
-         
+
          - ``indep_vars`` - a list of the two other independent
            variables.
 
@@ -348,7 +348,7 @@
             sage: x, y, z = var('x y z')
             sage: T = _ArbitraryCoordinates((x + y, x - y, z), z,[x,y])
             sage: f(x, y) = 2*x + y
-            sage: T.to_cartesian(f, [x, y])               
+            sage: T.to_cartesian(f, [x, y])
             (x + y, x - y, 2*x + y)
             sage: [h(1,2) for h in T.to_cartesian(lambda x,y: 2*x+y)]
             [3, -1, 4]
@@ -356,11 +356,11 @@
         self.dep_var = str(dep_var)
         self.indep_vars = [str(i) for i in indep_vars]
         self.custom_trans = tuple(custom_trans)
-        
+
     def transform(self, **kwds):
         """
         EXAMPLE::
-            
+
             sage: from sage.plot.plot3d.plot3d import _ArbitraryCoordinates
             sage: x, y, z = var('x y z')
             sage: T = _ArbitraryCoordinates((x + y, x - y, z), x,[y,z])
@@ -374,11 +374,11 @@
     """
     A spherical coordinate system for use with ``plot3d(transformation=...)``
     where the position of a point is specified by three numbers:
-    
+
     - the *radial distance* (``radius``) from the origin
 
     - the *azimuth angle* (``azimuth``) from the positive `x`-axis
-     
+
     - the *inclination angle* (``inclination``) from the positive `z`-axis
 
     These three variables must be specified in the constructor.
@@ -389,14 +389,14 @@
     in terms of the azimuth and inclination::
 
         sage: T = Spherical('radius', ['azimuth', 'inclination'])
-    
+
     If we construct some concrete variables, we can get a
     transformation in terms of those variables::
 
         sage: r, phi, theta = var('r phi theta')
         sage: T.transform(radius=r, azimuth=theta, inclination=phi)
         (r*sin(phi)*cos(theta), r*sin(phi)*sin(theta), r*cos(phi))
-    
+
     We can plot with this transform.  Remember that the dependent
     variable is the radius, and the independent variables are the
     azimuth and the inclination (in that order)::
@@ -418,7 +418,7 @@
         A spherical coordinates transform.
 
         EXAMPLE::
-        
+
             sage: T = Spherical('radius', ['azimuth', 'inclination'])
             sage: T.transform(radius=var('r'), azimuth=var('theta'), inclination=var('phi'))
             (r*sin(phi)*cos(theta), r*sin(phi)*sin(theta), r*cos(phi))
@@ -465,9 +465,9 @@
         sage: SE=SphericalElevation('elevation', ['radius', 'azimuth'])
         sage: r,theta=var('r,theta')
         sage: plot3d(3, (r,0,3), (theta, 0, 2*pi), transformation=SE)
-        
+
     Plot a sin curve wrapped around the equator::
-    
+
         sage: P1=plot3d( (pi/12)*sin(8*theta), (r,0.99,1), (theta, 0, 2*pi), transformation=SE, plot_points=(10,200))
         sage: P2=sphere(center=(0,0,0), size=1, color='red', opacity=0.3)
         sage: P1+P2
@@ -476,15 +476,15 @@
     inclination functions. This example illustrates the difference between the
     ``Spherical`` coordinate system and the ``SphericalElevation`` coordinate
     system::
-      
+
         sage: r, phi, theta = var('r phi theta')
         sage: SE = SphericalElevation('elevation', ['radius', 'azimuth'])
         sage: angles = [pi/18, pi/12, pi/6]
         sage: P1 = [plot3d( a, (r,0,3), (theta, 0, 2*pi), transformation=SE, opacity=0.85, color='blue') for a in angles]
-        
+
         sage: S = Spherical('inclination', ['radius', 'azimuth'])
         sage: P2 = [plot3d( a, (r,0,3), (theta, 0, 2*pi), transformation=S, opacity=0.85, color='red') for a in angles]
-        sage: show(sum(P1+P2), aspect_ratio=1)   
+        sage: show(sum(P1+P2), aspect_ratio=1)
 
     See also :func:`spherical_plot3d` for more examples of plotting in spherical
     coordinates.
@@ -508,11 +508,11 @@
     """
     A cylindrical coordinate system for use with ``plot3d(transformation=...)``
     where the position of a point is specified by three numbers:
-    
+
     - the *radial distance* (``radius``) from the `z`-axis
 
     - the *azimuth angle* (``azimuth``) from the positive `x`-axis
-     
+
     - the *height* or *altitude* (``height``) above the `xy`-plane
 
     These three variables must be specified in the constructor.
@@ -622,28 +622,28 @@
 def plot3d(f, urange, vrange, adaptive=False, transformation=None, **kwds):
     """
     INPUT:
-    
-    
+
+
     -  ``f`` - a symbolic expression or function of 2
        variables
-    
+
     -  ``urange`` - a 2-tuple (u_min, u_max) or a 3-tuple
        (u, u_min, u_max)
-    
+
     -  ``vrange`` - a 2-tuple (v_min, v_max) or a 3-tuple
        (v, v_min, v_max)
-    
+
     -  ``adaptive`` - (default: False) whether to use
        adaptive refinement to draw the plot (slower, but may look better).
        This option does NOT work in conjuction with a transformation
        (see below).
-    
+
     -  ``mesh`` - bool (default: False) whether to display
        mesh grid lines
-    
+
     -  ``dots`` - bool (default: False) whether to display
        dots at mesh grid points
-    
+
     -  ``plot_points`` - (default: "automatic") initial number of sample
        points in each direction; an integer or a pair of integers
 
@@ -659,65 +659,65 @@
       of independent variables.  ``transformation`` may also be a
       predefined coordinate system transformation like Spherical or
       Cylindrical.
-    
+
     .. note::
 
        ``mesh`` and ``dots`` are not supported when using the Tachyon
        raytracer renderer.
-    
+
     EXAMPLES: We plot a 3d function defined as a Python function::
-    
+
         sage: plot3d(lambda x, y: x^2 + y^2, (-2,2), (-2,2))
-    
+
     We plot the same 3d function but using adaptive refinement::
-    
+
         sage: plot3d(lambda x, y: x^2 + y^2, (-2,2), (-2,2), adaptive=True)
-    
+
     Adaptive refinement but with more points::
-    
+
         sage: plot3d(lambda x, y: x^2 + y^2, (-2,2), (-2,2), adaptive=True, initial_depth=5)
-    
+
     We plot some 3d symbolic functions::
-    
+
         sage: var('x,y')
         (x, y)
         sage: plot3d(x^2 + y^2, (x,-2,2), (y,-2,2))
         sage: plot3d(sin(x*y), (x, -pi, pi), (y, -pi, pi))
 
     We give a plot with extra sample points::
-    
+
         sage: var('x,y')
         (x, y)
         sage: plot3d(sin(x^2+y^2),(x,-5,5),(y,-5,5), plot_points=200)
         sage: plot3d(sin(x^2+y^2),(x,-5,5),(y,-5,5), plot_points=[10,100])
-    
+
     A 3d plot with a mesh::
-    
+
         sage: var('x,y')
         (x, y)
-        sage: plot3d(sin(x-y)*y*cos(x),(x,-3,3),(y,-3,3), mesh=True)     
-    
+        sage: plot3d(sin(x-y)*y*cos(x),(x,-3,3),(y,-3,3), mesh=True)
+
     Two wobby translucent planes::
-    
+
         sage: x,y = var('x,y')
         sage: P = plot3d(x+y+sin(x*y), (x,-10,10),(y,-10,10), opacity=0.87, color='blue')
         sage: Q = plot3d(x-2*y-cos(x*y),(x,-10,10),(y,-10,10),opacity=0.3,color='red')
         sage: P + Q
-    
+
     We draw two parametric surfaces and a transparent plane::
-    
+
         sage: L = plot3d(lambda x,y: 0, (-5,5), (-5,5), color="lightblue", opacity=0.8)
         sage: P = plot3d(lambda x,y: 4 - x^3 - y^2, (-2,2), (-2,2), color='green')
         sage: Q = plot3d(lambda x,y: x^3 + y^2 - 4, (-2,2), (-2,2), color='orange')
         sage: L + P + Q
-    
+
     We draw the "Sinus" function (water ripple-like surface)::
-    
+
         sage: x, y = var('x y')
         sage: plot3d(sin(pi*(x^2+y^2))/2,(x,-1,1),(y,-1,1))
-    
+
     Hill and valley (flat surface with a bump and a dent)::
-    
+
         sage: x, y = var('x y')
         sage: plot3d( 4*x*exp(-x^2-y^2), (x,-2,2), (y,-2,2))
 
@@ -760,16 +760,16 @@
         ... def _(which_plot=[F, G, H, I, J]):
         ...       show(which_plot)
         <html>...
-    
+
     TESTS:
 
     Make sure the transformation plots work::
 
         sage: show(A + B + C + D + E)
         sage: show(F + G + H + I + J)
-    
+
     Listing the same plot variable twice gives an error::
-    
+
         sage: x, y = var('x y')
         sage: plot3d( 4*x*exp(-x^2-y^2), (x,-2,2), (x,-2,2))
         Traceback (most recent call last):
@@ -821,53 +821,53 @@
     return P
 
 def plot3d_adaptive(f, x_range, y_range, color="automatic",
-                    grad_f=None, 
+                    grad_f=None,
                     max_bend=.5, max_depth=5, initial_depth=4, num_colors=128, **kwds):
     r"""
     Adaptive 3d plotting of a function of two variables.
-    
+
     This is used internally by the plot3d command when the option
     ``adaptive=True`` is given.
-    
+
     INPUT:
-    
-    
+
+
     -  ``f`` - a symbolic function or a Python function of
        3 variables.
-    
+
     -  ``x_range`` - x range of values: 2-tuple (xmin,
        xmax) or 3-tuple (x,xmin,xmax)
-    
+
     -  ``y_range`` - y range of values: 2-tuple (ymin,
        ymax) or 3-tuple (y,ymin,ymax)
-    
+
     -  ``grad_f`` - gradient of f as a Python function
-    
+
     -  ``color`` - "automatic" - a rainbow of num_colors
        colors
-    
+
     -  ``num_colors`` - (default: 128) number of colors to
        use with default color
-    
+
     -  ``max_bend`` - (default: 0.5)
-    
+
     -  ``max_depth`` - (default: 5)
-    
+
     -  ``initial_depth`` - (default: 4)
-    
+
     -  ``**kwds`` - standard graphics parameters
-    
-    
+
+
     EXAMPLES:
 
     We plot `\sin(xy)`::
-    
+
         sage: from sage.plot.plot3d.plot3d import plot3d_adaptive
         sage: x,y=var('x,y'); plot3d_adaptive(sin(x*y), (x,-pi,pi), (y,-pi,pi), initial_depth=5)
     """
     if initial_depth >= max_depth:
         max_depth = initial_depth
-    
+
     from sage.plot.misc import setup_for_eval_on_grid
     g, ranges = setup_for_eval_on_grid(f, [x_range,y_range], plot_points=2)
     xmin,xmax = ranges[0][:2]
@@ -883,12 +883,12 @@
         else:
             kwds['color'] = color
             texture = Texture(kwds)
-    
+
     factory = TrivialTriangleFactory()
     plot = TrianglePlot(factory, g, (xmin, xmax), (ymin, ymax), g = grad_f,
                         min_depth=initial_depth, max_depth=max_depth,
                         max_bend=max_bend, num_colors = None)
-    
+
     P = IndexFaceSet(plot._objects)
     if isinstance(texture, (list, tuple)):
         if len(texture) == 2:
@@ -917,7 +917,7 @@
     P.frame_aspect_ratio([1.0,1.0,0.5])
     P._set_extra_kwds(kwds)
     return P
-    
+
 def spherical_plot3d(f, urange, vrange, **kwds):
     """
     Plots a function in spherical coordinates.  This function is
@@ -929,7 +929,7 @@
         sage: plot3d(f, urange, vrange, transformation=T)
 
     or equivalently::
- 
+
         sage: T = Spherical('radius', ['azimuth', 'inclination'])
         sage: f=lambda u,v: u*v; urange=(u,0,pi); vrange=(v,0,pi)
         sage: plot3d(f, urange, vrange, transformation=T)
@@ -992,7 +992,7 @@
         sage: plot3d(f, urange, vrange, transformation=T)
 
     or equivalently::
- 
+
         sage: T = Cylindrical('radius', ['azimuth', 'height'])
         sage: f=lambda u,v: u*v; urange=(u,0,pi); vrange=(v,0,pi)
         sage: plot3d(f, urange, vrange, transformation=T)
@@ -1008,7 +1008,7 @@
 
     - ``vrange`` - a 3-tuple (v, v_min, v_max), the domain of the
       elevation (`z`) variable.
-     
+
     EXAMPLES:
 
     A portion of a cylinder of radius 2::
@@ -1043,13 +1043,13 @@
 
         sage: from sage.plot.plot3d.plot3d import axes
         sage: S = axes(6, color='black'); S
-    
+
     ::
-    
+
         sage: T = axes(2, .5); T
     """
     if radius is None:
         radius = scale/100.0
-    return Graphics3dGroup([arrow3d((0,0,0),(scale,0,0), radius, **kwds), 
-                            arrow3d((0,0,0),(0,scale,0), radius, **kwds), 
+    return Graphics3dGroup([arrow3d((0,0,0),(scale,0,0), radius, **kwds),
+                            arrow3d((0,0,0),(0,scale,0), radius, **kwds),
                             arrow3d((0,0,0),(0,0,scale), radius, **kwds)])
diff --git a/sage/plot/plot3d/plot_field3d.py b/sage/plot/plot3d/plot_field3d.py
--- a/sage/plot/plot3d/plot_field3d.py
+++ b/sage/plot/plot3d/plot_field3d.py
@@ -21,7 +21,7 @@
 from sage.modules.free_module_element import vector
 from sage.plot.plot import plot
 
-def plot_vector_field3d(functions, xrange, yrange, zrange, 
+def plot_vector_field3d(functions, xrange, yrange, zrange,
                         plot_points=5, colors='jet', center_arrows=False,**kwds):
     r"""
     Plot a 3d vector field
@@ -49,7 +49,7 @@
     - any other keywords are passed on to the plot command for each arrow
 
     EXAMPLES::
-    
+
         sage: x,y,z=var('x y z')
         sage: plot_vector_field3d((x*cos(z),-y*cos(z),sin(z)), (x,0,pi), (y,0,pi), (z,0,pi))
         sage: plot_vector_field3d((x*cos(z),-y*cos(z),sin(z)), (x,0,pi), (y,0,pi), (z,0,pi),colors=['red','green','blue'])
@@ -68,7 +68,7 @@
     xpoints, ypoints, zpoints = [srange(*r, include_endpoint=True) for r in ranges]
     points = [vector((i,j,k)) for i in xpoints for j in ypoints for k in zpoints]
     vectors = [vector((ff(*point), gg(*point), hh(*point))) for point in points]
-    
+
     try:
         from matplotlib.cm import get_cmap
         cm = get_cmap(colors)
@@ -79,10 +79,10 @@
             cm = LinearSegmentedColormap.from_list('mymap',colors)
         else:
             cm = lambda x: colors
-                
+
     max_len = max(v.norm() for v in vectors)
     scaled_vectors = [v/max_len for v in vectors]
-    
+
     if center_arrows:
         return sum([plot(v,color=cm(v.norm()),**kwds).translate(p-v/2) for v,p in zip(scaled_vectors, points)])
     else:
diff --git a/sage/plot/plot3d/revolution_plot3d.py b/sage/plot/plot3d/revolution_plot3d.py
--- a/sage/plot/plot3d/revolution_plot3d.py
+++ b/sage/plot/plot3d/revolution_plot3d.py
@@ -25,9 +25,9 @@
 def revolution_plot3d(curve,trange,phirange=None,parallel_axis='z',axis=(0,0),print_vector=False,show_curve=False,**kwds):
     """
     Return a plot of a revolved curve.
-    
+
     There are three ways to call this function:
-        
+
     - ``revolution_plot3d(f,trange)`` where `f` is a function located in the `x z` plane.
 
     - ``revolution_plot3d((f_x,f_z),trange)`` where `(f_x,f_z)` is a parametric curve on the `x z` plane.
@@ -35,7 +35,7 @@
     - ``revolution_plot3d((f_x,f_y,f_z),trange)`` where `(f_x,f_y,f_z)` can be any parametric curve.
 
     INPUT:
-    
+
     - ``curve`` - A curve to be revolved, specified as a function, a 2-tuple or a 3-tuple.
 
     - ``trange`` - A 3-tuple `(t,t_{\min},t_{\max})` where t is the independent variable of the curve.
@@ -45,39 +45,39 @@
     - ``parallel_axis`` - A string (Either 'x', 'y', or 'z') that specifies the coordinate axis parallel to the revolution axis.
 
     - ``axis`` - A 2-tuple that specifies the position of the revolution axis. If parallel is:
-        
+
         - 'z' - then axis is the point in which the revolution axis intersects the  `x y` plane.
-        
+
         - 'x' - then axis is the point in which the revolution axis intersects the  `y z` plane.
-        
+
         - 'y' - then axis is the point in which the revolution axis intersects the `x z` plane.
 
     - ``print_vector`` - If True, the parametrization of the surface of revolution will be printed.
 
     - ``show_curve`` - If True, the curve will be displayed.
 
-    
+
     EXAMPLES:
-        
+
     Let's revolve a simple function around different axes::
-        
+
         sage: u = var('u')
         sage: f=u^2
         sage: revolution_plot3d(f,(u,0,2),show_curve=True,opacity=0.7).show(aspect_ratio=(1,1,1))
 
     If we move slightly the axis, we get a goblet-like surface::
-    
+
         sage: revolution_plot3d(f,(u,0,2),axis=(1,0.2),show_curve=True,opacity=0.5).show(aspect_ratio=(1,1,1))
 
     A common problem in calculus books, find the volume within the following revolution solid::
-        
+
         sage: line=u
         sage: parabola=u^2
         sage: sur1=revolution_plot3d(line,(u,0,1),opacity=0.5,rgbcolor=(1,0.5,0),show_curve=True,parallel_axis='x')
         sage: sur2=revolution_plot3d(parabola,(u,0,1),opacity=0.5,rgbcolor=(0,1,0),show_curve=True,parallel_axis='x')
         sage: (sur1+sur2).show()
-            
-    
+
+
     Now let's revolve a parametrically defined circle. We can play with the topology of the surface by changing the axis, an axis in `(0,0)` (as the previous one) will produce a sphere-like surface::
 
         sage: u = var('u')
@@ -85,24 +85,24 @@
         sage: revolution_plot3d(circle,(u,0,2*pi),axis=(0,0),show_curve=True,opacity=0.5).show(aspect_ratio=(1,1,1))
 
     An axis on `(0,y)` will produce a cylinder-like surface::
-        
+
         sage: revolution_plot3d(circle,(u,0,2*pi),axis=(0,2),show_curve=True,opacity=0.5).show(aspect_ratio=(1,1,1))
 
     And any other axis will produce a torus-like surface::
-        
+
         sage: revolution_plot3d(circle,(u,0,2*pi),axis=(2,0),show_curve=True,opacity=0.5).show(aspect_ratio=(1,1,1))
-        
+
     Now, we can get another goblet-like surface by revolving a curve in 3d::
-        
+
         sage: u = var('u')
-        sage: curve=(u,cos(4*u),u^2) 
+        sage: curve=(u,cos(4*u),u^2)
         sage: revolution_plot3d(curve,(u,0,2),show_curve=True,parallel_axis='z',axis=(1,.2),opacity=0.5).show(aspect_ratio=(1,1,1))
-    
+
     A curvy curve with only a quarter turn::
-        
+
         sage: u = var('u')
         sage: curve=(sin(3*u),.8*cos(4*u),cos(u))
-        sage: revolution_plot3d(curve,(u,0,pi),(0,pi/2),show_curve=True,parallel_axis='z',opacity=0.5).show(aspect_ratio=(1,1,1),frame=False)            
+        sage: revolution_plot3d(curve,(u,0,pi),(0,pi/2),show_curve=True,parallel_axis='z',opacity=0.5).show(aspect_ratio=(1,1,1),frame=False)
     """
     from sage.symbolic.ring import var
     from sage.symbolic.constants import pi
@@ -110,14 +110,14 @@
     from sage.functions.trig import sin
     from sage.functions.trig import cos
     from sage.functions.trig import atan2
-    
-    
+
+
     if parallel_axis not in ['x','y','z']:
         raise ValueError, "parallel_axis must be either 'x', 'y', or 'z'."
-    
+
     vart=trange[0]
-    
-    
+
+
     if str(vart)=='phi':
         phi=var('fi')
     else:
diff --git a/sage/plot/plot3d/shapes2.py b/sage/plot/plot3d/shapes2.py
--- a/sage/plot/plot3d/shapes2.py
+++ b/sage/plot/plot3d/shapes2.py
@@ -46,51 +46,51 @@
 def line3d(points, thickness=1, radius=None, arrow_head=False, **kwds):
     r"""
     Draw a 3d line joining a sequence of points.
-    
+
     One may specify either a thickness or radius. If a thickness is
     specified, this line will have a constant diameter regardless of
     scaling and zooming. If a radius is specified, it will behave as a
     series of cylinders.
-    
+
     INPUT:
-    
-    
+
+
     -  ``points`` - a list of at least 2 points
-    
+
     -  ``thickness`` - (default: 1)
-    
+
     -  ``radius`` - (default: None)
-    
+
     -  ``arrow_head`` - (default: False)
-    
+
     -  ``color`` - a word that describes a color
-    
+
     -  ``rgbcolor`` - (r,g,b) with r, g, b between 0 and 1
        that describes a color
-    
+
     -  ``opacity`` - (default: 1) if less than 1 then is
        transparent
-    
-    
-    EXAMPLES: 
+
+
+    EXAMPLES:
 
     A line in 3-space::
-    
+
         sage: line3d([(1,2,3), (1,0,-2), (3,1,4), (2,1,-2)])
-    
+
     The same line but red::
-    
+
         sage: line3d([(1,2,3), (1,0,-2), (3,1,4), (2,1,-2)], color='red')
-    
+
     A transparent thick green line and a little blue line::
-    
+
         sage: line3d([(0,0,0), (1,1,1), (1,0,2)], opacity=0.5, radius=0.1, \
                      color='green') + line3d([(0,1,0), (1,0,2)])
-    
+
     A Dodecahedral complex of 5 tetrahedrons (a more elaborate examples
     from Peter Jipsen)::
-    
-        sage: def tetra(col): 
+
+        sage: def tetra(col):
         ...       return line3d([(0,0,1), (2*sqrt(2.)/3,0,-1./3), (-sqrt(2.)/3, sqrt(6.)/3,-1./3),\
         ...              (-sqrt(2.)/3,-sqrt(6.)/3,-1./3), (0,0,1), (-sqrt(2.)/3, sqrt(6.)/3,-1./3),\
         ...              (-sqrt(2.)/3,-sqrt(6.)/3,-1./3), (2*sqrt(2.)/3,0,-1./3)],\
@@ -156,46 +156,46 @@
     """
     Draws a 3-dimensional bezier path.  Input is similar to bezier_path, but each
     point in the path and each control point is required to have 3 coordinates.
-    
+
     INPUT:
-    
-    -  ``path`` - a list of curves, which each is a list of points. See further 
+
+    -  ``path`` - a list of curves, which each is a list of points. See further
         detail below.
-    
+
     -  ``thickness`` - (default: 2)
-    
+
     -  ``color`` - a word that describes a color
 
     -  ``opacity`` - (default: 1) if less than 1 then is
        transparent
-       
+
     -  ``aspect_ratio`` - (default:[1,1,1])
-    
-    The path is a list of curves, and each curve is a list of points.  
+
+    The path is a list of curves, and each curve is a list of points.
     Each point is a tuple (x,y,z).
-    
-    The first curve contains the endpoints as the first and last point 
+
+    The first curve contains the endpoints as the first and last point
     in the list.  All other curves assume a starting point given by the
     last entry in the preceding list, and take the last point in the list
     as their opposite endpoint.  A curve can have 0, 1 or 2 control points
-    listed between the endpoints.  In the input example for path below, 
+    listed between the endpoints.  In the input example for path below,
     the first and second curves have 2 control points, the third has one,
     and the fourth has no control points::
-    
+
         path = [[p1, c1, c2, p2], [c3, c4, p3], [c5, p4], [p5], ...]
-    
+
     In the case of no control points, a straight line will be drawn
-    between the two endpoints.  If one control point is supplied, then 
+    between the two endpoints.  If one control point is supplied, then
     the curve at each of the endpoints will be tangent to the line from
-    that endpoint to the control point.  Similarly, in the case of two 
+    that endpoint to the control point.  Similarly, in the case of two
     control points, at each endpoint the curve will be tangent to the line
     connecting that endpoint with the control point immediately after or
     immediately preceding it in the list.
-    
+
     So in our example above, the curve between p1 and p2 is tangent to the
     line through p1 and c1 at p1, and tangent to the line through p2 and c2
     at p2.  Similarly, the curve between p2 and p3 is tangent to line(p2,c3)
-    at p2 and tangent to line(p3,c4) at p3.  Curve(p3,p4) is tangent to 
+    at p2 and tangent to line(p3,c4) at p3.  Curve(p3,p4) is tangent to
     line(p3,c5) at p3 and tangent to line(p4,c5) at p4.  Curve(p4,p5) is a
     straight line.
 
@@ -206,7 +206,7 @@
         sage: b
 
     To construct a simple curve, create a list containing a single list::
-        
+
         sage: path = [[(0,0,0),(1,0,0),(0,1,0),(0,1,1)]]
         sage: curve = bezier3d(path, thickness=5, color='blue')
         sage: curve
@@ -214,7 +214,7 @@
     import parametric_plot3d as P3D
     from sage.modules.free_module_element import vector
     from sage.calculus.calculus import var
-    
+
     p0 = vector(path[0][-1])
     t = var('t')
     if len(path[0]) > 2:
@@ -222,7 +222,7 @@
         G = P3D.parametric_plot3d(list(B), (0, 1), color=options['color'], aspect_ratio=options['aspect_ratio'], thickness=options['thickness'], opacity=options['opacity'])
     else:
         G = line3d([path[0][0], p0], color=options['color'], thickness=options['thickness'], opacity=options['opacity'])
-    
+
     for curve in path[1:]:
         if len(curve) > 1:
             p1 = vector(curve[0])
@@ -234,7 +234,7 @@
             G += line3d([p0,curve[0]], color=options['color'], thickness=options['thickness'], opacity=options['opacity'])
         p0 = curve[-1]
     return G
-    
+
 @rename_keyword(alpha='opacity')
 @options(opacity=1, color=(0,0,1))
 def polygon3d(points, **options):
@@ -242,11 +242,11 @@
     Draw a polygon in 3d.
 
     INPUT:
-        
+
     - ``points`` - the vertices of the polygon
 
-    Type ``polygon3d.options`` for a dictionary of the default 
-    options for polygons.  You can change this to change 
+    Type ``polygon3d.options`` for a dictionary of the default
+    options for polygons.  You can change this to change
     the defaults for all future polygons.  Use ``polygon3d.reset()``
     to reset to the default options.
 
@@ -270,18 +270,18 @@
 
 def frame3d(lower_left, upper_right, **kwds):
     """
-    Draw a frame in 3-D.  Primarily used as a helper function for 
+    Draw a frame in 3-D.  Primarily used as a helper function for
     creating frames for 3-D graphics viewing.
 
     INPUT:
-        
+
     - ``lower_left`` - the lower left corner of the frame, as a
       list, tuple, or vector.
 
     - ``upper_right`` - the upper right corner of the frame, as a
       list, tuple, or vector.
 
-    Type ``line3d.options`` for a dictionary of the default 
+    Type ``line3d.options`` for a dictionary of the default
     options for lines, which are also available.
 
     EXAMPLES:
@@ -307,36 +307,36 @@
     v4 = line3d([(x1,y1,z0), (x1,y1,z1)], **kwds)
     F  = L1 + v2 + v3 + v4
     F._set_extra_kwds(kwds)
-    return F 
+    return F
 
 def frame_labels(lower_left, upper_right,
                  label_lower_left, label_upper_right, eps = 1,
                  **kwds):
     """
-    Draw correct labels for a given frame in 3-D.  Primarily 
+    Draw correct labels for a given frame in 3-D.  Primarily
     used as a helper function for creating frames for 3-D graphics
     viewing - do not use directly unless you know what you are doing!
 
     INPUT:
-        
+
     - ``lower_left`` - the lower left corner of the frame, as a
       list, tuple, or vector.
 
     - ``upper_right`` - the upper right corner of the frame, as a
       list, tuple, or vector.
 
-    - ``label_lower_left`` - the label for the lower left corner 
+    - ``label_lower_left`` - the label for the lower left corner
       of the frame, as a list, tuple, or vector.  This label must actually
       have all coordinates less than the coordinates of the other label.
 
-    - ``label_upper_right`` - the label for the upper right corner 
+    - ``label_upper_right`` - the label for the upper right corner
       of the frame, as a list, tuple, or vector.  This label must actually
       have all coordinates greater than the coordinates of the other label.
 
     - ``eps`` - (default: 1) a parameter for how far away from the frame
       to put the labels.
 
-    Type ``line3d.options`` for a dictionary of the default 
+    Type ``line3d.options`` for a dictionary of the default
     options for lines, which are also available.
 
     EXAMPLES:
@@ -402,17 +402,17 @@
     T += Text(fmt%lz1, color=color).translate((x0-eps,y0,z1))
     return T
 
-    
+
 def ruler(start, end, ticks=4, sub_ticks=4, absolute=False, snap=False, **kwds):
     """
     Draw a ruler in 3-D, with major and minor ticks.
 
     INPUT:
 
-    - ``start`` - the beginning of the ruler, as a list, 
+    - ``start`` - the beginning of the ruler, as a list,
       tuple, or vector.
 
-    - ``end`` - the end of the ruler, as a list, tuple, 
+    - ``end`` - the end of the ruler, as a list, tuple,
       or vector.
 
     - ``ticks`` - (default: 4) the number of major ticks
@@ -427,7 +427,7 @@
     - ``snap`` - (default: ``False``) if ``True``, snaps to an implied
       grid.
 
-    Type ``line3d.options`` for a dictionary of the default 
+    Type ``line3d.options`` for a dictionary of the default
     options for lines, which are also available.
 
     EXAMPLES:
@@ -463,21 +463,21 @@
     dir = end - start
     dist = math.sqrt(dir.dot_product(dir))
     dir /= dist
-    
+
     one_tick = dist/ticks * 1.414
     unit = 10 ** math.floor(math.log(dist/ticks, 10))
     if unit * 5 < one_tick:
         unit *= 5
     elif unit * 2 < one_tick:
         unit *= 2
-    
+
     if dir[0]:
         tick = dir.cross_product(vector(RDF, (0,0,-dist/30)))
     elif dir[1]:
         tick = dir.cross_product(vector(RDF, (0,0,dist/30)))
     else:
         tick = vector(RDF, (dist/30,0,0))
-        
+
     if snap:
         for i in range(3):
             start[i] = unit * math.floor(start[i]/unit + 1e-5)
@@ -497,7 +497,7 @@
     else:
         off = 0
         first_tick = 0
-        
+
     ruler = shapes.LineSegment(start, end, **kwds)
     for k in range(1, int(sub_ticks * first_tick/unit)):
         P = start + dir*(k*unit/sub_ticks)
@@ -512,7 +512,7 @@
             P += dir * (unit/sub_ticks)
             ruler += shapes.LineSegment(P, P + tick/2, **kwds)
     return ruler
-    
+
 def ruler_frame(lower_left, upper_right, ticks=4, sub_ticks=4, **kwds):
     """
     Draw a frame made of 3-D rulers, with major and minor ticks.
@@ -531,7 +531,7 @@
     - ``sub_ticks`` - (default: 4) the number of shown
       subdivisions between each major tick.
 
-    Type ``line3d.options`` for a dictionary of the default 
+    Type ``line3d.options`` for a dictionary of the default
     options for lines, which are also available.
 
     EXAMPLES:
@@ -548,7 +548,7 @@
     return ruler(lower_left, (upper_right[0], lower_left[1], lower_left[2]), ticks=ticks, sub_ticks=sub_ticks, absolute=True, **kwds) \
          + ruler(lower_left, (lower_left[0], upper_right[1], lower_left[2]), ticks=ticks, sub_ticks=sub_ticks, absolute=True, **kwds) \
          + ruler(lower_left, (lower_left[0], lower_left[1], upper_right[2]), ticks=ticks, sub_ticks=sub_ticks, absolute=True, **kwds)
-    
+
 
 
 
@@ -559,38 +559,38 @@
     r"""
     Return a plot of a sphere of radius size centered at
     `(x,y,z)`.
-    
+
     INPUT:
-    
-    
+
+
     -  ``(x,y,z)`` - center (default: (0,0,0)
-    
+
     -  ``size`` - the radius (default: 1)
-    
-    
+
+
     EXAMPLES: A simple sphere::
-    
+
         sage: sphere()
-    
+
     Two spheres touching::
-    
+
         sage: sphere(center=(-1,0,0)) + sphere(center=(1,0,0), aspect_ratio=[1,1,1])
-    
+
     Spheres of radii 1 and 2 one stuck into the other::
-    
+
         sage: sphere(color='orange') + sphere(color=(0,0,0.3), \
-                     center=(0,0,-2),size=2,opacity=0.9)    
-    
+                     center=(0,0,-2),size=2,opacity=0.9)
+
     We draw a transparent sphere on a saddle.
-    
+
     ::
-    
+
         sage: u,v = var('u v')
         sage: saddle = plot3d(u^2 - v^2, (u,-2,2), (v,-2,2))
         sage: sphere((0,0,1), color='red', opacity=0.5, aspect_ratio=[1,1,1]) + saddle
-        
+
     TESTS::
-    
+
         sage: T = sage.plot.plot3d.texture.Texture('red')
         sage: S = sphere(texture=T)
         sage: T in S.texture_set()
@@ -601,60 +601,60 @@
     H = G.translate(center)
     H._set_extra_kwds(kwds)
     return H
-    
+
 def text3d(txt, (x,y,z), **kwds):
     r"""
     Display 3d text.
-    
+
     INPUT:
-    
-    
+
+
     -  ``txt`` - some text
-    
+
     -  ``(x,y,z)`` - position
-    
+
     -  ``**kwds`` - standard 3d graphics options
-    
-    
+
+
     .. note::
 
        There is no way to change the font size or opacity yet.
-    
+
     EXAMPLES: We write the word Sage in red at position (1,2,3)::
-    
+
         sage: text3d("Sage", (1,2,3), color=(0.5,0,0))
-    
+
     We draw a multicolor spiral of numbers::
-    
+
         sage: sum([text3d('%.1f'%n, (cos(n),sin(n),n), color=(n/2,1-n/2,0)) \
                     for n in [0,0.2,..,8]])
-    
+
     Another example
-    
+
     ::
-    
+
         sage: text3d("Sage is really neat!!",(2,12,1))
-    
+
     And in 3d in two places::
-    
+
         sage: text3d("Sage is...",(2,12,1), rgbcolor=(1,0,0)) + text3d("quite powerful!!",(4,10,0), rgbcolor=(0,0,1))
     """
     if not kwds.has_key('color') and not kwds.has_key('rgbcolor'):
         kwds['color'] = (0,0,0)
     G = Text(txt, **kwds).translate((x,y,z))
     G._set_extra_kwds(kwds)
-    
+
     return G
 
 class Point(PrimitiveObject):
     """
     Create a position in 3-space, represented by a sphere of fixed
     size.
-    
+
     INPUT:
-    
+
     -  ``center`` - point (3-tuple)
-    
+
     -  ``size`` - (default: 1)
 
     EXAMPLE:
@@ -680,7 +680,7 @@
         self.loc = (float(center[0]), float(center[1]), float(center[2]))
         self.size = size
         self._set_extra_kwds(kwds)
-        
+
     def bounding_box(self):
         """
         Returns the lower and upper corners of a 3-D bounding box for ``self``.
@@ -694,13 +694,13 @@
             ((-3.0, 2.0, 10.0), (-3.0, 2.0, 10.0))
         """
         return self.loc, self.loc
-        
+
     def tachyon_repr(self, render_params):
         """
         Returns representation of the point suitable for plotting
         using the Tachyon ray tracer.
 
-        TESTS:: 
+        TESTS::
 
             sage: P = point3d((1,2,3),size=3,color='purple')
             sage: P.tachyon_repr(P.default_render_params())
@@ -712,12 +712,12 @@
         else:
             cen = transform.transform_point(self.loc)
         return "Sphere center %s %s %s Rad %s %s" % (cen[0], cen[1], cen[2], self.size * TACHYON_PIXEL, self.texture.id)
-        
+
     def obj_repr(self, render_params):
         """
         Returns complete representation of the point as a sphere.
 
-        TESTS:: 
+        TESTS::
 
             sage: P = point3d((1,2,3),size=3,color='purple')
             sage: P.obj_repr(P.default_render_params())[0][0:2]
@@ -732,13 +732,13 @@
         cmds = S.obj_repr(render_params)
         render_params.pop_transform()
         return cmds
-                
+
     def jmol_repr(self, render_params):
         r"""
         Returns representation of the object suitable for plotting
         using Jmol.
 
-        TESTS:: 
+        TESTS::
 
             sage: P = point3d((1,2,3),size=3,color='purple')
             sage: P.jmol_repr(P.default_render_params())
@@ -752,31 +752,31 @@
 class Line(PrimitiveObject):
     r"""
     Draw a 3d line joining a sequence of points.
-    
+
     This line has a fixed diameter unaffected by transformations and
     zooming. It may be smoothed if ``corner_cutoff < 1``.
-    
-    INPUT:    
-    
+
+    INPUT:
+
     -  ``points`` - list of points to pass through
-    
+
     -  ``thickness`` - diameter of the line
-    
+
     -  ``corner_cutoff`` - threshold for smoothing (see
        the corners() method) this is the minimum cosine between adjacent
        segments to smooth
-    
+
     -  ``arrow_head`` - if True make this curve into an
        arrow
-    
-    
+
+
     EXAMPLES::
-    
+
         sage: from sage.plot.plot3d.shapes2 import Line
         sage: Line([(i*math.sin(i), i*math.cos(i), i/3) for i in range(30)], arrow_head=True)
-    
+
     Smooth angles less than 90 degrees::
-    
+
         sage: Line([(0,0,0),(1,0,0),(2,1,0),(0,1,0)], corner_cutoff=0)
     """
     def __init__(self, points, thickness=5, corner_cutoff=.5, arrow_head=False, **kwds):
@@ -798,7 +798,7 @@
         self.thickness = thickness
         self.corner_cutoff = corner_cutoff
         self.arrow_head = arrow_head
-    
+
     def bounding_box(self):
         """
         Returns the lower and upper corners of a 3-D bounding box for ``self``.
@@ -825,7 +825,7 @@
         Returns representation of the line suitable for plotting
         using the Tachyon ray tracer.
 
-        TESTS:: 
+        TESTS::
 
             sage: L = line3d([(cos(i),sin(i),i^2) for i in srange(0,10,.01)],color='red')
             sage: L.tachyon_repr(L.default_render_params())[0]
@@ -854,7 +854,7 @@
         """
         Returns complete representation of the line as an object.
 
-        TESTS:: 
+        TESTS::
 
             sage: from sage.plot.plot3d.shapes2 import Line
             sage: L = Line([(cos(i),sin(i),i^2) for i in srange(0,10,.01)],color='red')
@@ -870,13 +870,13 @@
         cmds = L.obj_repr(render_params)
         render_params.pop_transform()
         return cmds
-        
+
     def jmol_repr(self, render_params):
         r"""
         Returns representation of the object suitable for plotting
         using Jmol.
 
-        TESTS:: 
+        TESTS::
 
             sage: L = line3d([(cos(i),sin(i),i^2) for i in srange(0,10,.01)],color='red')
             sage: L.jmol_repr(L.default_render_params())[0][:42]
@@ -902,38 +902,38 @@
         cmds.append(cmd)
         cmds.append(self.texture.jmol_str('$'+name))
         return cmds
-         
+
     def corners(self, corner_cutoff=None, max_len=None):
         """
         Figures out where the curve turns too sharply to pretend it's
         smooth.
-        
+
         INPUT: Maximum cosine of angle between adjacent line segments
         before adding a corner
-        
+
         OUTPUT: List of points at which to start a new line. This always
         includes the first point, and never the last.
-        
+
         EXAMPLES:
-        
+
         Every point::
-        
+
             sage: from sage.plot.plot3d.shapes2 import Line
             sage: Line([(0,0,0),(1,0,0),(2,1,0),(0,1,0)], corner_cutoff=1).corners()
             [(0, 0, 0), (1, 0, 0), (2, 1, 0)]
-        
+
         Greater than 90 degrees::
-        
+
             sage: Line([(0,0,0),(1,0,0),(2,1,0),(0,1,0)], corner_cutoff=0).corners()
             [(0, 0, 0), (2, 1, 0)]
-        
+
         No corners::
-        
+
             sage: Line([(0,0,0),(1,0,0),(2,1,0),(0,1,0)], corner_cutoff=-1).corners()
             (0, 0, 0)
-        
+
         An intermediate value::
-        
+
             sage: Line([(0,0,0),(1,0,0),(2,1,0),(0,1,0)], corner_cutoff=.5).corners()
             [(0, 0, 0), (2, 1, 0)]
         """
@@ -956,7 +956,7 @@
             next_dir = [next[i] - cur[i] for i in range(3)]
             corners = [cur]
             cur, prev_dir = next, next_dir
-    
+
             # quicker than making them vectors first
             def dot((x0,y0,z0), (x1,y1,z1)):
                 return x0*x1 + y0*y1 + z0*z1
@@ -975,32 +975,32 @@
                 cur, prev_dir = next, next_dir
                 count += 1
             return corners
-            
-    
-        
+
+
+
 def point3d(v, size=5, **kwds):
     """
     Plot a point or list of points in 3d space.
-    
+
     INPUT:
-    
-    
+
+
     -  ``v`` - a point or list of points
-    
+
     -  ``size`` - (default: 5) size of the point (or
        points)
-    
+
     -  ``color`` - a word that describes a color
-    
+
     -  ``rgbcolor`` - (r,g,b) with r, g, b between 0 and 1
        that describes a color
-    
+
     -  ``opacity`` - (default: 1) if less than 1 then is
        transparent
-    
-    
+
+
     EXAMPLES::
-    
+
         sage: sum([point3d((i,i^2,i^3), size=5) for i in range(10)])
 
     We check to make sure this works with vectors::
@@ -1009,12 +1009,12 @@
         sage: p = point(vector((2,3,4)))
         sage: print p
         Graphics3d Object
-        
+
 
     We check to make sure the options work::
 
         sage: point3d((4,3,2),size=20,color='red',opacity=.5)
-        
+
     """
     if (isinstance(v,(list,tuple)) or is_Vector(v)) and len(v) == 3 and not (isinstance(v[0],(list,tuple)) or is_Vector(v[0])):
         return Point(v, size, **kwds)
@@ -1022,4 +1022,4 @@
         A = sum([Point(z, size, **kwds) for z in v])
         A._set_extra_kwds(kwds)
         return A
-    
+
diff --git a/sage/plot/plot3d/tachyon.py b/sage/plot/plot3d/tachyon.py
--- a/sage/plot/plot3d/tachyon.py
+++ b/sage/plot/plot3d/tachyon.py
@@ -214,7 +214,7 @@
         Creates an instance of the Tachyon class.
 
         EXAMPLES::
-        
+
             sage: t = Tachyon()
             sage: t._xres
             350
@@ -286,7 +286,7 @@
            line. Use tachyon_rt.usage() to see some of the possibilities.
 
         EXAMPLES::
-        
+
             sage: q = Tachyon()
             sage: q.light((1,1,11), 1,(1,1,1))
             sage: q.texture('s')
@@ -325,7 +325,7 @@
 
     def _res(self):
         r"""
-        An internal function that writes the tachyon string for the 
+        An internal function that writes the tachyon string for the
         resolution (x and y size of the image).
 
         EXAMPLES::
@@ -338,7 +338,7 @@
 
     def _camera(self):
         r"""
-        An internal function that writes the tachyon string for the 
+        An internal function that writes the tachyon string for the
         camera and other rendering information (ray depth, antialiasing).
 
         EXAMPLES::
@@ -395,7 +395,7 @@
     def light(self, center, radius, color):
         r"""
         Creates a light source of the given center, radius, and color.
-        
+
         EXAMPLES::
 
             sage: q = Tachyon()
@@ -554,7 +554,7 @@
 
     def cylinder(self, center, axis, radius, texture):
         r"""
-        Creates the scene information for a infinite cylinder with the 
+        Creates the scene information for a infinite cylinder with the
         given center, axis direction, radius, and texture.
 
         EXAMPLES::
@@ -593,11 +593,11 @@
     def fcylinder(self, base, apex, radius, texture):
         r"""
         Finite cylinders are almost the same as infinite ones, but the
-        center and length of the axis determine the extents of the 
-        cylinder.  The finite cylinder is also really a shell, it 
-        doesn't have any caps. If you need to close off the ends of 
-        the cylinder, use two ring objects, with the inner radius set 
-        to 0.0 and the normal set to be the axis of the cylinder. 
+        center and length of the axis determine the extents of the
+        cylinder.  The finite cylinder is also really a shell, it
+        doesn't have any caps. If you need to close off the ends of
+        the cylinder, use two ring objects, with the inner radius set
+        to 0.0 and the normal set to be the axis of the cylinder.
         Finite cylinders are built this way to enhance speed.
 
         EXAMPLES::
@@ -614,7 +614,7 @@
         Creates a triangle with the given vertices and texture.
 
         EXAMPLES::
-        
+
             sage: t = Tachyon()
             sage: t.texture('s')
             sage: t.triangle([1,2,3],[4,5,6],[7,8,10],'s')
@@ -629,7 +629,7 @@
         Creates a triangle along with a normal vector for smoothing.
 
         EXAMPLES::
-        
+
             sage: t = Tachyon()
             sage: t.light((1,1,1),.1,(1,1,1))
             sage: t.texture('s')
@@ -644,7 +644,7 @@
         Axis-aligned fractal landscape.  Not very useful at the moment.
 
         EXAMPLES::
-            
+
             sage: t = Tachyon()
             sage: t.texture('s')
             sage: t.fractal_landscape([30,30],[80,80],[0,0,0],'s')
@@ -751,7 +751,7 @@
 #        Add a set of objects to the scene from a collection.
 #
 #        EXAMPLES::
-#        
+#
 #            sage: t = Tachyon()
 #            sage: t.texture('s')
 #            sage: for i in range(10): t.sphere((0,0,i),i,'s')
@@ -772,7 +772,7 @@
     def __init__(self, center, radius, color):
         r"""
         Stores the center, radius and color.
-        
+
         EXAMPLES::
 
             sage: from sage.plot.plot3d.tachyon import Light
@@ -882,9 +882,9 @@
     def str(self):
         r"""
         Returns the scene string for this texture.
-        
+
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.tachyon import Texture
             sage: t = Texture('w')
             sage: t.str().split()[2:6]
@@ -915,7 +915,7 @@
         Stores the center, radius, and texture information in a class.
 
         EXAMPLES::
-        
+
             sage: t = Tachyon()
             sage: from sage.plot.plot3d.tachyon import Sphere
             sage: t.texture('r', color=(.8,0,0), ambient = .1)
@@ -983,7 +983,7 @@
 
 class FractalLandscape:
     r"""
-    Axis-aligned fractal landscape.  
+    Axis-aligned fractal landscape.
     Does not seem very useful at the moment, but perhaps will be improved in the future.
     """
     def __init__(self, res, scale, center, texture):
@@ -1001,7 +1001,7 @@
         self._scale = scale
         self._center = center
         self._texture = texture
-    
+
     def str(self):
         r"""
         Returns the scene string of the fractal landscape.
@@ -1026,7 +1026,7 @@
         Creates a cylinder with the given parameters.
 
         EXAMPLES::
-        
+
             sage: t = Tachyon()
             sage: from sage.plot.plot3d.tachyon import Cylinder
             sage: c = Cylinder((0,0,0),(1,1,1),.1,'s')
@@ -1043,7 +1043,7 @@
         Returns the scene string of the cylinder.
 
         EXAMPLES::
-        
+
             sage: t = Tachyon()
             sage: from sage.plot.plot3d.tachyon import Cylinder
             sage: c = Cylinder((0,0,0),(1,1,1),.1,'s')
@@ -1063,7 +1063,7 @@
         Creates the plane object.
 
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.tachyon import Plane
             sage: p = Plane((1,2,3),(1,2,4),'s')
             sage: p.str()
@@ -1078,7 +1078,7 @@
         Returns the scene string of the plane.
 
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.tachyon import Plane
             sage: p = Plane((1,2,3),(1,2,4),'s')
             sage: p.str()
@@ -1210,7 +1210,7 @@
         Initializes with tachyon instance and texture.
 
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.tachyon import TachyonTriangleFactory
             sage: t = Tachyon()
             sage: t.texture('s')
@@ -1226,7 +1226,7 @@
         Creates a TachyonTriangle with vertices a, b, and c.
 
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.tachyon import TachyonTriangleFactory
             sage: t = Tachyon()
             sage: t.texture('s')
@@ -1245,7 +1245,7 @@
         Creates a TachyonSmoothTriangle.
 
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.tachyon import TachyonTriangleFactory
             sage: t = Tachyon()
             sage: t.texture('s')
@@ -1264,7 +1264,7 @@
         Returns a list of color labels.
 
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.tachyon import TachyonTriangleFactory
             sage: t = Tachyon()
             sage: t.texture('s')
diff --git a/sage/plot/plot3d/texture.py b/sage/plot/plot3d/texture.py
--- a/sage/plot/plot3d/texture.py
+++ b/sage/plot/plot3d/texture.py
@@ -1,10 +1,10 @@
 r"""
 Texture Support
 
-This module provides texture/material support for 3D Graphics 
-objects and plotting.  This is a very rough common interface for 
-Tachyon, x3d, and obj (mtl).   See 
-:meth:`Texture <sage.plot.plot3d.texture.Texture>` and 
+This module provides texture/material support for 3D Graphics
+objects and plotting.  This is a very rough common interface for
+Tachyon, x3d, and obj (mtl).   See
+:meth:`Texture <sage.plot.plot3d.texture.Texture>` and
 :class:`Texture_class <sage.plot.plot3d.texture.Texture_class>`
 for full details about options and use.
 
@@ -32,7 +32,7 @@
 AUTHOR:
 
 - Robert Bradshaw (2007-07-07) Initial version.
-    
+
 """
 from sage.structure.sage_object import SageObject
 
@@ -162,13 +162,13 @@
         uniq_c += 1
         id = "texture%s" % uniq_c
     return Texture_class(id, **kwds)
-    
+
 def parse_color(info, base=None):
     r"""
-    Parses the color. 
-    
+    Parses the color.
+
     It transforms a valid color string into a color object and
-    a color object into an RBG tuple of length 3. Otherwise, 
+    a color object into an RBG tuple of length 3. Otherwise,
     it multiplies the info by the base color.
 
     INPUT:
@@ -225,8 +225,8 @@
 
 class Texture_class(SageObject):
     r"""
-    Construction of a texture. 
-    
+    Construction of a texture.
+
     See documentation of :meth:`Texture <sage.plot.plot3d.texture.Texture>` for more details and examples.
 
     EXAMPLES:
@@ -248,8 +248,8 @@
     """
     def __init__(self, id, color=(.4, .4, 1), opacity=1, ambient=0.5, diffuse=1, specular=0, shininess=1, name=None, **kwds):
         r"""
-        Construction of a texture. 
-        
+        Construction of a texture.
+
         See documentation of :meth:`Texture <sage.plot.plot3d.texture.Texture>` for more details and examples.
 
         EXAMPLES::
@@ -262,18 +262,18 @@
         if name is None and isinstance(color, str):
             name = color
         self.name = name
-        
+
         if not isinstance(color, tuple):
             color = parse_color(color)
         else:
             if len(color) == 4:
                 opacity = color[3]
             color = (float(color[0]), float(color[1]), float(color[2]))
-            
+
         self.color = color
         self.opacity = opacity
         self.shininess = shininess
-        
+
         if not isinstance(ambient, tuple):
             ambient = parse_color(ambient, color)
         self.ambient = ambient
@@ -285,13 +285,13 @@
         if not isinstance(specular, tuple):
             specular = parse_color(specular, color)
         self.specular = specular
-        
+
     def _repr_(self):
         """
         Gives string representation of the Texture object.
 
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.texture import Texture
             sage: Texture('yellow')               #indirect doctest
             Texture(texture..., yellow, ffff00)
@@ -302,11 +302,11 @@
             return "Texture(%s, %s, %s)" % (self.id, self.name, self.hex_rgb())
         else:
             return "Texture(%s, %s)" % (self.id, self.hex_rgb())
-    
+
     def hex_rgb(self):
         """
         EXAMPLES::
-        
+
             sage: from sage.plot.plot3d.texture import Texture
             sage: Texture('red').hex_rgb()
             'ff0000'
@@ -314,7 +314,7 @@
             'ff7f00'
         """
         return "%02x%02x%02x" % tuple(int(255*s) for s in self.color)
-        
+
     def tachyon_str(self):
         r"""
         Converts Texture object to string suitable for Tachyon ray tracer.
@@ -331,9 +331,9 @@
             total_color = 1
         return "Texdef %s\n" % self.id + \
          "  Ambient %s Diffuse %s Specular %s Opacity %s\n" % \
-                (sum(self.ambient)/total_color, 
-                 sum(self.diffuse)/total_color, 
-                 sum(self.specular)/total_color, 
+                (sum(self.ambient)/total_color,
+                 sum(self.diffuse)/total_color,
+                 sum(self.specular)/total_color,
                  self.opacity) + \
         "   Color %s %s %s\n" % (self.color[0], self.color[1], self.color[2]) + \
         "   TexFunc 0"
@@ -351,7 +351,7 @@
         """
         return "<Appearance><Material diffuseColor='%s %s %s' shininess='%s' specularColor='%s %s %s'/></Appearance>" % \
                 (self.color[0], self.color[1], self.color[2], self.shininess, self.specular[0], self.specular[0], self.specular[0])
-                
+
     def mtl_str(self):
         r"""
         Converts Texture object to string suitable for mtl output.
@@ -385,7 +385,7 @@
             sage: t = Texture(opacity=0.6)
             sage: t.jmol_str('obj')
             'color obj translucent 0.4 [102,102,255]'
-            
+
         ::
 
             sage: sum([dodecahedron(center=[2.5*x, 0, 0], color=(1, 0, 0, x/10)) for x in range(11)]).show(aspect_ratio=[1,1,1], frame=False, zoom=2)
diff --git a/sage/plot/plot3d/tri_plot.py b/sage/plot/plot3d/tri_plot.py
--- a/sage/plot/plot3d/tri_plot.py
+++ b/sage/plot/plot3d/tri_plot.py
@@ -102,7 +102,7 @@
         da, db, dc : triples (dx,dy,dz) representing the normal vector at each point a,b,c
 
         TESTS::
-        
+
             sage: from sage.plot.plot3d.tri_plot import SmoothTriangle
             sage: t = SmoothTriangle([1,2,3],[2,3,4],[0,0,0],[0,0,1],[0,1,0],[1,0,0])
             sage: t._a
@@ -120,11 +120,11 @@
         """
         Returns a string representation of the SmoothTriangle of the form
         a b c da db dc color
-        where a, b, and c are the triangle corner coordinates, 
+        where a, b, and c are the triangle corner coordinates,
         da, db, dc are normals at each corner, and color is the color.
 
         TESTS::
-        
+
             sage: from sage.plot.plot3d.tri_plot import SmoothTriangle
             sage: t = SmoothTriangle([1,2,3],[2,3,4],[0,0,0],[0,0,1],[0,1,0],[1,0,0])
             sage: print t.__repr__()
@@ -137,7 +137,7 @@
         Returns the normals to vertices a, b, and c.
 
         TESTS::
-        
+
             sage: from sage.plot.plot3d.tri_plot import SmoothTriangle
             sage: t = SmoothTriangle([1,2,3],[2,3,4],[0,0,0],[0,0,1],[0,1,0],[2,0,0])
             sage: t.get_normals()
@@ -195,13 +195,13 @@
         Parameters:
           list: an iterable collection of values which can be cast into colors -- typically an
                   RGB triple, or an RGBA 4-tuple
-        
+
         Returns:
           a list of single parameters which can be passed into the set_color method of the
                   Triangle or SmoothTriangle objects generated by this factory.
-        
+
         TESTS::
-        
+
             sage: from sage.plot.plot3d.tri_plot import TriangleFactory
             sage: factory = TriangleFactory()
             sage: factory.get_colors([1,2,3])
@@ -538,14 +538,14 @@
 
 def crossunit(u,v):
     """
-    This function computes triangle normal unit vectors by taking the 
-    cross-products of the midpoint-to-corner vectors.  It always goes 
-    around clockwise so we're guaranteed to have a positive value near 
-    1 when neighboring triangles are parallel.  However -- crossunit 
-    doesn't really return a unit vector.  It returns the length of the 
-    vector to avoid numerical instability when the length is nearly zero 
-    -- rather than divide by nearly zero, we multiply the other side of 
-    the inequality by nearly zero -- in general, this should work a bit 
+    This function computes triangle normal unit vectors by taking the
+    cross-products of the midpoint-to-corner vectors.  It always goes
+    around clockwise so we're guaranteed to have a positive value near
+    1 when neighboring triangles are parallel.  However -- crossunit
+    doesn't really return a unit vector.  It returns the length of the
+    vector to avoid numerical instability when the length is nearly zero
+    -- rather than divide by nearly zero, we multiply the other side of
+    the inequality by nearly zero -- in general, this should work a bit
     better because of the density of floating-point numbers near zero.
 
     TESTS::
diff --git a/sage/plot/plot_field.py b/sage/plot/plot_field.py
--- a/sage/plot/plot_field.py
+++ b/sage/plot/plot_field.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -30,7 +30,7 @@
 class PlotField(GraphicPrimitive):
     """
     Primitive class that initializes the
-    PlotField graphics type 
+    PlotField graphics type
     """
     def __init__(self, xpos_array, ypos_array, xvec_array, yvec_array, options):
         """
@@ -68,7 +68,7 @@
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-                
+
         EXAMPLES::
 
             sage: x,y = var('x,y')
@@ -125,7 +125,7 @@
         quiver_options = options.copy()
         quiver_options.pop('plot_points')
         subplot.quiver(self.xpos_array, self.ypos_array, self.xvec_array, self.yvec_array, angles='xy', **quiver_options)
- 
+
 @options(plot_points=20,frame=True)
 def plot_vector_field((f, g), xrange, yrange, **options):
     r"""
@@ -136,7 +136,7 @@
 
     ``plot_vector_field((f, g), (xvar, xmin, xmax), (yvar, ymin, ymax))``
 
-    EXAMPLES: 
+    EXAMPLES:
 
     Plot some vector fields involving sin and cos::
 
@@ -146,7 +146,7 @@
     ::
 
         sage: plot_vector_field(( y, (cos(x)-2)*sin(x)), (x,-pi,pi), (y,-pi,pi))
-    
+
     Plot a gradient field::
 
         sage: u,v = var('u v')
@@ -154,7 +154,7 @@
         sage: plot_vector_field(f.gradient(), (u,-2,2), (v,-2,2), color='blue')
 
     Plot two orthogonal vector fields::
-        
+
         sage: x,y = var('x,y')
         sage: a=plot_vector_field((x,y), (x,-3,3),(y,-3,3),color='blue')
         sage: b=plot_vector_field((y,-x),(x,-3,3),(y,-3,3),color='red')
@@ -205,7 +205,7 @@
 
     ``plot_slope_field(f, (xvar, xmin, xmax), (yvar, ymin, ymax))``
 
-    EXAMPLES: 
+    EXAMPLES:
 
     A logistic function modeling population growth::
 
@@ -227,7 +227,7 @@
 
     Verify that we're not getting warnings due to use of headless quivers
     (trac #11208)::
-    
+
         sage: x,y = var('x y')
         sage: import numpy # bump warnings up to errors for testing purposes
         sage: old_err = numpy.seterr('raise')
diff --git a/sage/plot/point.py b/sage/plot/point.py
--- a/sage/plot/point.py
+++ b/sage/plot/point.py
@@ -12,7 +12,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -75,7 +75,7 @@
             sage: P[0].options()['alpha']
             1
         """
-        self.xdata = xdata 
+        self.xdata = xdata
         self.ydata = ydata
         GraphicPrimitive_xydata.__init__(self, options)
 
@@ -99,7 +99,7 @@
 
     def _plot3d_options(self, options=None):
         """
-        Translate 2D plot options into 3D plot options. 
+        Translate 2D plot options into 3D plot options.
 
         EXAMPLES::
 
@@ -131,8 +131,8 @@
         Plots a two-dimensional point in 3-D, with default height zero.
 
         INPUT:
-    
-    
+
+
         -  ``z`` - optional 3D height above `xy`-plane.  May be a list
            if self is a list of points.
 
@@ -252,13 +252,13 @@
         We check to make sure that \#2076 is fixed by verifying all
         the points are red::
 
-            sage: point(((1,1), (2,2), (3,3)), rgbcolor=hue(1), size=30) 
+            sage: point(((1,1), (2,2), (3,3)), rgbcolor=hue(1), size=30)
         """
         options = self.options()
 
-        #Convert the color to a hex string so that the scatter 
+        #Convert the color to a hex string so that the scatter
         #method does not interpret it as a list of 3 floating
-        #point color specifications when there are 
+        #point color specifications when there are
         #three points. This is mentioned in the matplotlib 0.98
         #documentation and fixes \#2076
         from matplotlib.colors import rgb2hex
@@ -271,7 +271,7 @@
         scatteroptions={}
         if not faceted: scatteroptions['edgecolors'] = 'none'
         subplot.scatter(self.xdata, self.ydata, s=s, c=c, alpha=a, zorder=z, label=options['legend_label'], **scatteroptions)
-        
+
 
 def point(points, **kwds):
     """
@@ -279,7 +279,7 @@
 
     INPUT:
 
-    -  ``points`` - either a single point (as a tuple) or a list of points. 
+    -  ``points`` - either a single point (as a tuple) or a list of points.
 
     For information regarding additional arguments, see either point2d?
     or point3d?.
@@ -325,12 +325,12 @@
     A purple point from a single tuple or coordinates::
 
         sage: point((0.5, 0.5), rgbcolor=hue(0.75))
-        
+
     Passing an empty list returns an empty plot::
-        
+
         sage: point([])
 
-    If you need a 2D point to live in 3-space later, 
+    If you need a 2D point to live in 3-space later,
     this is possible::
 
         sage: A=point((1,1))
diff --git a/sage/plot/polygon.py b/sage/plot/polygon.py
--- a/sage/plot/polygon.py
+++ b/sage/plot/polygon.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -24,7 +24,7 @@
 class Polygon(GraphicPrimitive_xydata):
     """
     Primitive class for the Polygon graphics type.  For information
-    on actual plotting, please see :func:`polygon`, :func:`polygon2d`, 
+    on actual plotting, please see :func:`polygon`, :func:`polygon2d`,
     or :func:`~sage.plot.plot3d.shapes2.polygon3d`.
 
     INPUT:
@@ -153,7 +153,7 @@
 
     def _plot3d_options(self, options=None):
         """
-        Translate 2d plot options into 3d plot options. 
+        Translate 2d plot options into 3d plot options.
 
         EXAMPLES::
 
@@ -175,8 +175,8 @@
         Plots a 2D polygon in 3D, with default height zero.
 
         INPUT:
-    
-    
+
+
         -  ``z`` - optional 3D height above `xy`-plane, or a list of
            heights corresponding to the list of 2D polygon points.
 
@@ -232,7 +232,7 @@
 
             sage: P = polygon([(0,0), (1,2), (0,1), (-1,2)])
         """
-        import matplotlib.patches as patches        
+        import matplotlib.patches as patches
         options = self.options()
         p = patches.Polygon([(self.xdata[i],self.ydata[i]) for i in xrange(len(self.xdata))])
         p.set_linewidth(float(options['thickness']))
@@ -278,11 +278,11 @@
     r"""
     Returns a 2-dimensional polygon defined by ``points``.
 
-    Type ``polygon.options`` for a dictionary of the default 
-    options for polygons.  You can change this to change 
-    the defaults for all future polygons.  Use ``polygon.reset()`` 
+    Type ``polygon.options`` for a dictionary of the default
+    options for polygons.  You can change this to change
+    the defaults for all future polygons.  Use ``polygon.reset()``
     to reset to the default options.
-    
+
     EXAMPLES:
 
     We create a purple-ish polygon::
@@ -317,7 +317,7 @@
 
         sage: L = [[6*cos(pi*i/100)+5*cos((6/2)*pi*i/100),6*sin(pi*i/100)-5*sin((6/2)*pi*i/100)] for i in range(200)]
         sage: polygon2d(L, rgbcolor=(1/8,1/4,1/2))
-        
+
     Another one::
 
         sage: n = 4; h = 5; b = 2
@@ -353,7 +353,7 @@
     AUTHORS:
 
     - David Joyner (2006-04-14): the long list of examples above.
-    
+
     """
     from sage.plot.plot import xydata_from_point_list
     from sage.plot.all import Graphics
@@ -368,4 +368,4 @@
     g.add_primitive(Polygon(xdata, ydata, options))
     if options['legend_label']:
         g.legend(True)
-    return g 
+    return g
diff --git a/sage/plot/primitive.py b/sage/plot/primitive.py
--- a/sage/plot/primitive.py
+++ b/sage/plot/primitive.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -49,7 +49,7 @@
             Graphics primitive
         """
         self._options = options
-        
+
     def _allowed_options(self):
         """
         Return the allowed options for a graphics primitive.
@@ -81,10 +81,10 @@
             NotImplementedError: 3D plotting not implemented for Graphics primitive
         """
         raise NotImplementedError, "3D plotting not implemented for %s" % self._repr_()
-        
+
     def _plot3d_options(self, options=None):
         """
-        Translate 2D plot options into 3D plot options. 
+        Translate 2D plot options into 3D plot options.
 
         EXAMPLES::
 
@@ -107,13 +107,13 @@
             options_3d['opacity'] = options['alpha']
             del options['alpha']
         if 'legend_label' in options:
-            del options['legend_label'] # no equivalent in 3d for now            
+            del options['legend_label'] # no equivalent in 3d for now
         if 'zorder' in options:
             del options['zorder']
         if len(options) != 0:
             raise NotImplementedError, "Unknown plot3d equivalent for %s" % ", ".join(options.keys())
         return options_3d
-    
+
     def set_zorder(self, zorder):
         """
         Set the layer in which to draw the object.
@@ -134,7 +134,7 @@
             3
         """
         self._options['zorder'] = zorder
-        
+
     def options(self):
         """
         Return the dictionary of options for this graphics primitive.
@@ -176,7 +176,7 @@
             O['rgbcolor'] = hue(*t)
             del O['hue']
         return O
-    
+
     def _repr_(self):
         """
         String representation of this graphics primitive.
@@ -195,7 +195,7 @@
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: d = polygon([[1,2], [5,6], [5,0]], rgbcolor=(1,0,1))[0].get_minmax_data()
@@ -220,7 +220,7 @@
             100.0
             sage: d['xmax']
             120.0
-        
+
         """
         from sage.plot.plot import minmax_data
         return minmax_data(self.xdata, self.ydata, dict=True)
diff --git a/sage/plot/scatter_plot.py b/sage/plot/scatter_plot.py
--- a/sage/plot/scatter_plot.py
+++ b/sage/plot/scatter_plot.py
@@ -5,7 +5,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #                     2009 Emily Kirkman
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
@@ -28,9 +28,9 @@
 
     Input consists of two lists/arrays of the same length, whose
     values give the horizontal and vertical coordinates of each
-    point in the scatter plot.  Options may be passed in 
+    point in the scatter plot.  Options may be passed in
     dictionary format.
-        
+
     EXAMPLES::
 
         sage: from sage.plot.scatter_plot import ScatterPlot
@@ -40,7 +40,7 @@
     def __init__(self, xdata, ydata, options):
         """
         Scatter plot graphics primitive.
-        
+
         EXAMPLES::
 
             sage: import numpy
@@ -50,12 +50,12 @@
         """
         self.xdata = xdata
         self.ydata = ydata
-        GraphicPrimitive.__init__(self, options)      
+        GraphicPrimitive.__init__(self, options)
 
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data.
-        
+
         EXAMPLES::
 
             sage: s = scatter_plot([[0,1],[2,4],[3.2,6]])
@@ -126,7 +126,7 @@
 
             sage: scatter_plot([[n,n] for n in range(5)])
         """
-        from matplotlib.pyplot import scatter  
+        from matplotlib.pyplot import scatter
         options = self.options()
         p = subplot.scatter(self.xdata, self.ydata, alpha=options['alpha'],
                 zorder=options['zorder'], marker=options['marker'],
@@ -138,10 +138,10 @@
 @options(alpha=1, markersize=50, marker='o', zorder=5, facecolor='#fec7b8', edgecolor='black', clip=True, aspect_ratio='automatic')
 def scatter_plot(datalist, **options):
     """
-    Returns a Graphics object of a scatter plot containing all points in 
+    Returns a Graphics object of a scatter plot containing all points in
     the datalist.  Type ``scatter_plot.options`` to see all available
     plotting options.
-    
+
     INPUT:
 
     - ``datalist`` -- a list of tuples ``(x,y)``
@@ -168,11 +168,11 @@
     - ``edgecolor`` -- default: ``'black'``
 
     - ``zorder`` -- default: 5
-        
+
     EXAMPLES::
 
         sage: scatter_plot([[0,1],[2,2],[4.3,1.1]], marker='s')
-        
+
     Extra options will get passed on to :meth:`~Graphics.show`, as long as they are valid::
 
         sage: scatter_plot([(0, 0), (1, 1)], markersize=100, facecolor='green', ymax=100)
diff --git a/sage/plot/step.py b/sage/plot/step.py
--- a/sage/plot/step.py
+++ b/sage/plot/step.py
@@ -39,7 +39,7 @@
     We plot the prime counting function::
 
         sage: plot_step_function([(i,prime_pi(i)) for i in range(20)])
-    
+
         sage: plot_step_function([(i,sin(i)) for i in range(5,20)])
 
     We pass in many options and get something that looks like "Space Invaders"::
diff --git a/sage/plot/text.py b/sage/plot/text.py
--- a/sage/plot/text.py
+++ b/sage/plot/text.py
@@ -4,7 +4,7 @@
 #*****************************************************************************
 #       Copyright (C) 2006 Alex Clemesha <clemesha@gmail.com>,
 #                          William Stein <wstein@gmail.com>,
-#                     2008 Mike Hansen <mhansen@gmail.com>, 
+#                     2008 Mike Hansen <mhansen@gmail.com>,
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -54,7 +54,7 @@
     def get_minmax_data(self):
         """
         Returns a dictionary with the bounding box data. Notice
-        that, for text, the box is just the location itself. 
+        that, for text, the box is just the location itself.
 
         EXAMPLES::
 
@@ -91,8 +91,8 @@
             'How big the text is.'
             sage: T[0]._allowed_options()['zorder']
             'The layer level in which to draw'
-            sage: T[0]._allowed_options()['rotation'] 
-            'how to rotate the text: angle in degrees, vertical, horizontal' 
+            sage: T[0]._allowed_options()['rotation']
+            'how to rotate the text: angle in degrees, vertical, horizontal'
         """
         return {'fontsize': 'How big the text is.',
                 'rgbcolor':'The color as an RGB tuple.',
@@ -106,7 +106,7 @@
 
     def _plot3d_options(self, options=None):
         """
-        Translate 2D plot options into 3D plot options. 
+        Translate 2D plot options into 3D plot options.
 
         EXAMPLES::
 
@@ -183,7 +183,7 @@
 def text(string, xy, **options):
     r"""
     Returns a 2D text graphics object at the point `(x,y)`.
-    
+
     Type ``text.options`` for a dictionary of options for 2D text.
 
     2D OPTIONS:
@@ -202,7 +202,7 @@
 
     - ``axis_coords`` - (default: False) if True, use axis coordinates, so that
       (0,0) is the lower left and (1,1) upper right, regardless of the x and y
-      range of plotted values. 
+      range of plotted values.
 
     EXAMPLES::
 
@@ -243,7 +243,7 @@
         sage: t = text3d("hi",(1,2,3))
 
     Extra options will get passed on to show(), as long as they are valid::
-    
+
         sage: text("MATH IS AWESOME", (0, 0), fontsize=40, axes=False)
         sage: text("MATH IS AWESOME", (0, 0), fontsize=40).show(axes=False) # These are equivalent
     """
