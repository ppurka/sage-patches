# HG changeset patch
# User Punarbasu Purkayastha <ppurka@gmail.com>
# Date 1352464426 -28800
# Node ID a43f83b9e6536fa8860bc33083665d1d70c07897
# Parent  deb09b0979aa7af53ab6159e6a2f248cb3b69ee1
implement __getitem__ for a linear code

diff --git a/sage/coding/linear_code.py b/sage/coding/linear_code.py
--- a/sage/coding/linear_code.py
+++ b/sage/coding/linear_code.py
@@ -1532,6 +1532,74 @@
         G = MS([Grref.row(i) for i in range(r)])
         return LinearCode(G)
 
+    def __getitem__(self, i):
+        """
+        Returns the `i`-th codeword of this code.
+
+        EXAMPLES::
+            sage: RS = ReedSolomonCode(7, 3, GF(8, 'a'))
+            sage: RS[24]
+            (0, a^2 + a, a^2 + a + 1, a^2 + 1, 1, a, a^2)
+            sage: RS[24] == RS.list()[24]
+            True
+
+        TESTS::
+
+            sage: C = random_matrix(GF(25,'a'), 2, 7).row_space()
+            sage: C = LinearCode(C.basis_matrix())
+            sage: Clist = C.list()
+            sage: sum([C[i]==Clist[i] for i in xrange(len(C))]) == len(C)
+            True
+        """
+        from sage.rings.padics.factory import Zp
+        F = self.base_ring()
+        a = F.primitive_element()
+        m = F.degree()
+        p = F.prime_subfield().order()
+        A = [a**k for k in xrange(m)]
+        G = self.gen_mat()
+        N = self.dimension()*F.degree() # the total length of p-adic vector
+        Z = Zp(p, N)
+        ivec = Z(i).padded_list(N)
+
+        # the implementation of this depends on the method used in
+        # the __iter__() function in this class.
+        #
+        # IMPORTANT: If the __iter__() function implementation is changed
+        # then the implementation here must also be changed so that
+        # list(self)[i] and self[i] both return the same element.
+        #
+        # The implementation is as follows. Suppose that
+        #  * the primitive element of self.base_ring() is a,
+        #  * the prime subfield is p,
+        #  * the field has order p^m,
+        #  * the code has dimension k,
+        #  * and the generator matrix is G.
+        # Then the __iter__() method returns the elements in this order:
+        #    i) first, the following ordered list is returned:
+        #       [i*a^0 * G[0] for i in range(p)]
+        #   ii) Next, the following ordered list is returned:
+        #       [i*a^0 * G[0] + a^1*G[0] for i in range(p)]
+        #  iii) This continues till we get
+        #       [(i*a^0 +(p-1)*a^1 +...+ (p-1)*a^(m-1))*G[0] for i in range(p)]
+        #  iii) Then, we move to G[1]:
+        #       [i*a^0 * G[0] + a^0*G[1] for i in range(p)]
+        #  and so on.
+        #  Hence the i-th element can be obtained by the p-adic expansion
+        #  of i as [i_0, i_1, ...,i_{m-1}, i_m, i_{m+1}, ..., i_{km-1}].
+        #  The element that is generated is
+        #  (i_0 * a^0 + i_1 * a^1 + ... + i_{m-1} * a^{m-1}) * G[0] +
+        #  (i_m * a^0 + i_{m+1}*a^1 + ... + i_{2m-1}*a^{m-1}) * G[1] +
+        #  ... +
+        #  (i_{(k-1)m}*a^0 + ... + i_{km-1}*a^{m-1}) * G[k-1]
+        #
+        codeword = 0
+        row = 0
+        for g in G:
+            codeword += sum([ivec[j+row*m]*A[j] for j in xrange(m)])*g
+            row += 1
+        return codeword
+
     def gen_mat(self):
         r"""
         Return a generator matrix of this code.
